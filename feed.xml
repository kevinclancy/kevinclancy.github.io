<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-11-09T20:25:22-08:00</updated><id>/feed.xml</id><title type="html">Kevin Clancy</title><subtitle></subtitle><author><name></name></author><entry><title type="html">Modelling Tic-Tac-Toe</title><link href="/2025/10/18/modelling-tic-tac-toe.html" rel="alternate" type="text/html" title="Modelling Tic-Tac-Toe" /><published>2025-10-18T09:35:00-07:00</published><updated>2025-10-18T09:35:00-07:00</updated><id>/2025/10/18/modelling-tic-tac-toe</id><content type="html" xml:base="/2025/10/18/modelling-tic-tac-toe.html"><![CDATA[<p>\(\newcommand{vrt}[2]{\left ( \begin{array}{l} #1 \\ #2 \end{array} \right )}\)
\(\newcommand{defeq}{\overset{\mathit{def}}{=}}\)
\(\newcommand{am}{\text{a.m.}}\)
\(\newcommand{pm}{\text{p.m.}}\)</p>

<h1 id="overview">Overview</h1>

<p>This post is a continuation of <a href="/posts/2025/07/11/towards-mathematical-model.html">Towards a Mathematical Model of Computer Games</a>. Unlike that post, this one is focused on mathematical rigor rather than motivation. Rather than defining a mathematical model of a MegaZeux game, it pursues the less ambitious goal of defining a mathematical model of tic-tac-toe. The game tic-tac-toe shares some common characteristics with a MegaZeux game.</p>

<p>The game involves two players. Each of these players is analogous to a MegaZeux robot, and the game board plays the role of the environment. The players repeatedly make requests to the board to alter its state. The board may or may not honor those requests depending on whether they obey its “laws of physics”.</p>

<p>The two players together with their environment will form a <em>closed system</em>, i.e. a set \(\mathit{GameState}\) with an update function</p>

\[\mathit{nextState} : \mathit{GameState} \to \mathit{GameState}\]

<p>Or equivalently, a set of two functions, using \(1 = \{ \ast \}\) as both the input and output sets:</p>

\[\mathit{output} : \mathit{GameState} \to 1\]

<p>and</p>

\[\mathit{nextState} : 1 \times \mathit{GameState} \to \mathit{GameState}\]

<p>We will construct this closed system out of open systems such as the players. The players are open systems that takes observations of the board state as inputs and produces move choices as outputs. As a rough first approximation, a player can be diagrammed as follows:</p>

<center>
<img src="/assets/images/gameloop/ttt-player.drawio.png" />
</center>

<p>The above system is considered <em>open</em> because its input and output are not one-element sets. Each turn, an element of BoardState is received as input. The player uses the current board state, possibly along with the player’s own internal state, to decide a move to submit to the board.</p>

<p>Now, let’s develop a formalism that allows us to compose complex systems from simpler systems.</p>

<h1 id="lenses">Lenses</h1>

<p>We model open systems mathematically using a construct called <em>lenses</em>. I learned about lenses from <a href="https://www.davidjaz.com/Papers/DynamicalBook.pdf">Categorical Systems Theory</a>, which I highly recommend. In the interest of self-containment, I will rehash the fundamentals of lenses now.</p>

<h2 id="definitions">Definitions</h2>

<blockquote>
  <p><strong>Definition</strong></p>

  <p>An <strong>arena</strong> \(\vrt{A^-}{A^+}\) is a pair consisting of two sets \(A^-\) and \(A^+\).</p>
</blockquote>

<blockquote>
  <p><strong>Definition</strong></p>

  <p>A <strong>lens</strong> \(\vrt{f^\sharp}{f} : \vrt{A^-}{A^+} \leftrightarrows \vrt{B^-}{B^+}\) is a pair consisting of two functions:</p>
  <ul>
    <li>A passforward function \(f : A^+ \to B^+\)</li>
    <li>A passback function \(f^\sharp : A^+ \times B^- \to A^-\)</li>
  </ul>

  <p>The arena \(\vrt{A^-}{A^+}\) is called the <strong>domain</strong> of \(\vrt{f^\sharp}{f}\) and the arena \(\vrt{B^-}{B^+}\) is called the <strong>codomain</strong> of \(\vrt{f^\sharp}{f}\).</p>
</blockquote>

<p>The passforward function of a lens can be viewed as sending information “downstream” and the passback function can be viewed as sending information “upstream”. One particularly important type of lens is a discrete dynamical system.</p>

<blockquote>
  <p><strong>Definition</strong></p>

  <p>A <strong>discrete dynamical system</strong> (or <strong>dynamical system</strong> for short) is a lens of the form</p>

\[\vrt{\mathit{nextState}}{\mathit{output}} : \vrt{\mathit{State}}{\mathit{State}} \leftrightarrows \vrt{\mathit{In}}{\mathit{Out}}\]

  <p>That is, a dynamical system is a lens whose codomain is an arena of the form \(\vrt{\mathit{State}}{\mathit{State}}\) for some set \(\mathit{State}\).</p>
</blockquote>

<p>Above, we consider \(\mathit{State}\) the type of our dynamical system’s internal state, \(\mathit{In}\) the type of its inputs, and \(\mathit{Out}\) the type of its outputs. Expanding the definition of lens, we see that</p>
<ul>
  <li>\(\mathit{nextState} : \mathit{State} \times \mathit{In} \to \mathit{State}\) is a function that takes a pair of a “current” state and an input to a “next” state.</li>
  <li>\(\mathit{output} : \mathit{State} \to \mathit{Out}\) is a function that takes a state to an output.</li>
</ul>

<p>This matches the intuitive structure of game engines that I presented previously. Those familiar with digital logic may know the distinction between <em>Moore machines</em> and <em>Mealy machines</em>. The output of a Mealy machine may depend both on its input and its current state, whereas the output of a Moore machine may only depend on its current state. In this sense, a dynamical system is like a Moore machine rather than a Mealy machine: before its input can affect its output, it must store the input in its state as an intermediate step. This can be a bit awkward sometimes, but it’s not a fundamental problem.</p>

<p>A dynamical system named \(S\) can be depicted as follows</p>

<figure>
<img src="/assets/images/gameloop/discrete-dynamical-system.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>
Figure 1
</figcaption>
</figure>

<p>If the codomain of one lens matches the domain of another then we can compose them together.</p>

<blockquote>
  <p><strong>Definition</strong></p>

  <p>Given lenses \(\vrt{f^\sharp}{f} : \vrt{A^-}{A^+} \leftrightarrows \vrt{B^-}{B^+}\) and
\(\vrt{g^\sharp}{g} : \vrt{B^-}{B^+} \leftrightarrows \vrt{C^-}{C^+}\) their <strong>composite</strong>
\(\vrt{g^\sharp}{g} \circ \vrt{f^{\sharp}}{f}\) is defined as \(\vrt{h^\sharp}{h}\), where</p>

  <ul>
    <li>\(h\) is defined as the function composite \(g \circ f\)</li>
    <li>\(h^\sharp\) is defined such that \(h^\sharp(a^+, c^-) \defeq f^\sharp(a^+, g^\sharp(f(a^+), c^-))\)</li>
  </ul>
</blockquote>

<p>We also have a parallel composition operator on lenses.</p>

<blockquote>
  <p><strong>Definition</strong></p>

  <p>Given two lenses \(\vrt{f^\sharp}{f} : \vrt{A^-}{A^+} \leftrightarrows \vrt{B^-}{B^+}\) and
\(\vrt{g^\sharp}{g} : \vrt{C^-}{C^+} \leftrightarrows \vrt{D^-}{D^+}\) we define their parallel
product
\(\vrt{f^\sharp}{f} \otimes \vrt{g^\sharp}{g} : \vrt{A^- \times C^-}{A^+ \times C^+} \leftrightarrows \vrt{B^- \times D^-}{B^+ \times D^+}\) is defined as the lens
\(\vrt{h^\sharp}{h}\), where</p>

\[h(a^+, c^+) \defeq (f(a^+), g(c^+))\]

  <p>and</p>

\[h^\sharp(a^+, c^+, b^-, d^-) \defeq (f^\sharp(a^+, b^-), g^\sharp(c^+, d^-))\]
</blockquote>

<p>Given dynamical systems</p>

\[\vrt{nextState_S}{output_S} : \vrt{\mathit{State}_S}{\mathit{State}_S} \leftrightarrows \vrt{\mathit{In}_S}{\mathit{Out}_S}\]

<p>and</p>

\[\vrt{nextState_T}{output_T} : \vrt{\mathit{State}_T}{\mathit{State}_T} \leftrightarrows \vrt{\mathit{In}_T}{\mathit{Out}_T}\]

<p>their parallel product</p>

\[\vrt{nextState_S}{output_S} \otimes \vrt{nextState_T}{output_T} : \vrt{\mathit{State}_S \times \mathit{State}_T}{\mathit{State}_S \times \mathit{State}_T} \leftrightarrows \vrt{\mathit{In}_S \times \mathit{In}_T}{\mathit{Out}_S \times \mathit{Out}_T}\]

<p>can be depicted by juxtaposing the two dynamical systems.</p>

<figure>
<img src="/assets/images/gameloop/parallel-product.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 2</figcaption>
</figure>

<h2 id="example">Example</h2>

<p>Here is an example of a dynamical system from <a href="link">Categorical Dynamical Systems</a>. Define the set</p>

\[\mathit{Hour} \defeq \{ 1,2,3,4,5,6,7,8,9,10,11,12 \}\]

<p>We define a dynamical system</p>

\[\mathit{Clock} : \vrt{\mathit{Hour}}{\mathit{Hour}} \leftrightarrows \vrt{1}{\mathit{Hour}} \defeq \vrt{f^\sharp}{f}\]

<p>where \(f\) is the identity function</p>

\[f(x) \defeq x\]

<p>and</p>

\[f^\sharp(h, \ast) \defeq \begin{cases}
1 &amp; \text{  if } h = 12 \\
h + 1 &amp; \text{  otherwise}
\end{cases}\]

<p>This system represents a wall clock, which takes no internal input and advances one hour forward at each step.</p>

<figure>
<img src="/assets/images/gameloop/clock.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 3</figcaption>
</figure>

<p>Note that we don’t need to draw an incoming edge; because the input is \(1 = \{ \ast \}\), it transmits only one possible value \(\ast\), and so the location the input comes from is irrelevant.</p>

<p>The above clock does not distinguish between \(\am\) and \(\pm\) To fix this,
we define a dynamical system called \(Meridiem\) that shifts between \(\am\) and \(\pm\) We first define the set
\(\am/\pm \defeq \{ \am, \pm \}\)
Then we define</p>

\[\mathit{Meridiem} : \vrt{\am/\pm}{\am/\pm} \leftrightarrows \vrt{\mathit{Hour}}{\am/\pm} \defeq \vrt{f^\sharp}{f}\]

<p>where</p>

\[f(m) \defeq m\]

<p>and</p>

\[f^\sharp(\am,h) \defeq \begin{cases}
\pm &amp; \text{if } h = 11 \\
\am &amp; \text{otherwise}
\end{cases}\]

\[f^\sharp(\pm,h) \defeq \begin{cases}
\am &amp; \text{if } h = 11 \\
\pm &amp; \text{otherwise}
\end{cases}\]

<p>Now we need “wire together” the \(\mathit{Clock}\) and \(\mathit{Meridiem}\) systems. As a first step, we take their paralell product.</p>

\[\mathit{Clock} \otimes \mathit{Meridiem} :
\vrt{\mathit{Hour} \times \am/\pm}{\mathit{Hour} \times \am/\pm} \leftrightarrows \vrt{1 \times \mathit{Hour}}{\mathit{Hour} \times \am/\pm}\]

<figure>
<img src="/assets/images/gameloop/clock-meridiem.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 4</figcaption>
</figure>

<p>To feed the output of \(\mathit{Clock}\) into \(\mathit{Meridiem}\), we use composition, which
can be depicted as nesting.</p>

<figure>
<img src="/assets/images/gameloop/compose-clock.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 5</figcaption>
</figure>

<p>The inner dotted box is the parallel product \(\mathit{Clock} \otimes \mathit{Meridiem}\). The outer dotted box is the fully wired system. The section between the two boxes depicts a new lens</p>

\[\vrt{w^\sharp}{w} : \vrt{1 \times \mathit{Hour}}{\mathit{Hour} \times \am/\pm} \leftrightarrows \vrt{1}{\mathit{Hour} \times \am/\pm}\]

<p>defined such that</p>

\[w(h,m) \defeq (h,m)\]

<p>and</p>

\[w^\sharp(h, m, \ast) \defeq (\ast, h)\]

<p>The fully wired system, which we shall call \(\mathit{Clock}'\) is then defined as</p>

\[\mathit{Clock}' : \vrt{\mathit{Hour} \times \am/\pm}{\mathit{Hour} \times \am/\pm} \leftrightarrows \vrt{1}{\mathit{Hour} \times \am/\pm} \defeq \vrt{w^\sharp}{w} \circ (\mathit{Clock} \otimes \mathit{Meridiem})\]

<h2 id="combinational-systems">Combinational Systems</h2>

<p>Suppose that we want to translate the output of the \(\mathit{Clock}'\) system above to
24-hour time, also known as “military time”, instead of \(\am/\pm\) Let</p>

\[\mathit{Hour24} \defeq \{ 0, 1, 2, \ldots, 23 \}\]

<p>We need to “post-compose” a function \(f : \mathit{Hour} \times \am/\pm \to \mathit{Hour24}\) after
the \(\mathit{Clock}'\) system, where \(f\) is defined as follows:</p>

\[f(h, \am) \defeq \begin{cases}
0 &amp; \text{if } h = 12 \\
h &amp; \text{otherwise}
\end{cases}\]

\[f(h, \pm) \defeq \begin{cases}
12 &amp; \text{if } h = 12 \\
12 + h &amp; \text{otherwise}
\end{cases}\]

<p>Such a post-composition is depicted below</p>

<figure>
<img src="/assets/images/gameloop/24-conversion.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 6</figcaption>
</figure>

<p>Note that \(f\) is just a function, not a dynamical system with state.</p>

<p>In digital logic, a circuit that stores state is known as sequential, whereas a circuit that
merely computes a function is called combinational. The function \(f\) above, having no internal state, is combinational. We can post-compose a dynamical system by a combinational system using lens combination.</p>

<p>Without loss of generality, let \(\mathit{Out}_0 \defeq \mathit{Hour} \times \am/\pm\), let
\(\mathit{Out}_1 \defeq \mathit{Hour24}\), and let \(\mathit{In} \defeq 1\).
Then this lens should translate the system’s output using a function \(f : \mathit{Out}_0 \to \mathit{Out}_1\)  but leave the input \(\mathit{In}\) unchanged. Hence we define it as</p>

\[\vrt{\pi_1}{f} : \vrt{\mathit{In}}{\mathit{Out_0}} \leftrightarrows \vrt{\mathit{In}}{\mathit{Out}_1}\]

<p>where \(\pi_1 : \mathit{Out_0} \times \mathit{In} \to \mathit{In}\) is the projection of the second component \((o,i) \mapsto i\).</p>

<p>We then obtain our military time clock as</p>

\[\mathit{MilitaryClock} \defeq \vrt{\pi_1}{f} \circ \mathit{Clock'}\]

<h2 id="demultiplexors">Demultiplexors</h2>

<p>Imagine a turn-based board game with multiple players. At each turn, we want to provide exactly one player with the state of the board so that they can make an informed move. The challenge is to send a payload value along a different wire depending on some selector value, and to send “nothing” along all other wires. More precisely, we need a combinational circuit, called a <em>demultiplexor</em>, that takes two inputs</p>

<ul>
  <li>The <em>payload</em>, whose type \(\mathit{Payload}\) may vary</li>
  <li>The <em>selector</em> of type <strong>n + 1</strong>, deciding which, if any, of \(n\) output destinations to transmit the payload to</li>
</ul>

<p>The demultiplexor circuit has \(n\) different output wires. Their type is not quite \(\mathit{Payload}\); each wire may contain a value of type \(\mathit{Payload}\) or, if it has not been selected, it may contain “no information” of type \(1\).</p>

<p>To express the set of values that each belong to exactly one of the disjoint sets \(\mathit{Payload}\) or \(1\) we need to use the <em>sum</em> set theoretic operation, which is not as well known as its evil twin the Cartesian product.</p>

<blockquote>
  <p><strong>Definition</strong> Given sets \(X\) and \(Y\), their sum \(X + Y\) is defined as</p>

\[X + Y \defeq \{ (0,x) \mid x \in X \} \cup \{ (1,y) \mid y \in Y \}\]
</blockquote>

<p>By tagging values with either \(0\) or \(1\), we ensure that the elements of the two operands are treated as mutually exclusive. It may be instructive to compare the set \(1 = 1 \cup 1\) with the set \(1 + 1\).</p>

<p>While we’re add it, let’s define another set-theoretic operation.</p>

<blockquote>
  <p><strong>Definition</strong> Given sets \(X\) and \(Y\), \(X^Y\) is defined as the set of functions from \(Y\)
to \(X\). In other words, \(X^Y\) is a synonym for \(Y \to X\).</p>
</blockquote>

<p>Now we are ready to formally define the notion of demultiplexor circuits.</p>

<blockquote>
  <p><strong>Definition</strong> The <strong>demultiplexor</strong> \(\mathit{demux}(\mathit{In}, X, n)\) is the combinational lens</p>

\[\vrt{\pi_1}{f} : \vrt{\mathit{In}}{X \times (\mathbf{n + 1})} \leftrightarrows \vrt{\mathit{In}}{(1 + X)^\mathbf{n}}\]

  <p>where \(f : X \times (\mathbf{n + 1}) \to (1 + X)^\mathbf{n}\) is defined such that</p>

\[f(x, m)(k) \defeq \begin{cases}
(1,x) &amp; \text{ if } m = k \\
(0,\ast) &amp; \text{ if } m \neq k
\end{cases}\]

  <p>and \(\pi_1 : (X \times (\mathbf{n + 1})) \times \mathit{In} \to \mathit{In}\) is the second projection function</p>

\[\pi_1((x, m), i) \defeq i\]
</blockquote>

<p>Thus, the demultiplexor \(\mathit{demux}(\mathit{In}, X,n)\) allows us to either</p>

<ul>
  <li><em>Select</em> some \(m \in \mathbf{n}\) such that \((1,x)\) is transmitted along the \(m^{\mathit{th}}\) output wire and \((0,\ast)\) is transmitted along all other output wires.</li>
  <li>Or, if \(m = n\), then transmit \((0,\ast)\) along all wires.</li>
</ul>

<p>\(\mathit{demux}(\mathit{In}, X,n)\) is depicted below, where we’ve elided all but the first and last of the \(n\) output wires.</p>

<figure>
<img src="/assets/images/gameloop/demux.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Diagram 7</figcaption>
</figure>

<p>Note that \(\mathit{demux}(\mathit{In}, X, n)\) can only be post-composed with a dynamical system whose input set is \(\mathit{In}\). When a demultiplexor is post-composed with a system \(S : \vrt{\mathit{State}_S}{\mathit{State}_S} \leftrightarrows \vrt{\mathit{In}_S}{\mathit{Out}_S}\), we elide the \(\mathit{In}\) argument from \(\mathit{demux}\), instead inferring from context that \(\mathit{In} = \mathit{In}_S\):</p>

<figure>
<img src="/assets/images/gameloop/demux-postcompose.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 8</figcaption>
</figure>

<h2 id="multiplexors">Multiplexors</h2>

<p>Assume \(n\) inputs of type \((1 + X)\), and further assume that we expect at most one input to have the form \((1, x)\) while the others have the form \((0,\ast)\). We want a combinational lens that produces a single output of type \(1 + X\), and which forwards \((1,x)\) if a single input has the form \((1,x)\) and forwards \((0,x)\) otherwise.</p>

<blockquote>
  <p><strong>Definition</strong> The <strong>multiplexor</strong> \(\mathit{mux}(\mathit{In}, X, n)\) is the combinational lens</p>

\[\vrt{\pi_1}{f} : \vrt{\mathit{In}}{(1 + X)^\mathbf{n}} \leftrightarrows \vrt{\mathit{In}}{1 + X}\]

  <p>where \(f : (1 + X)^\mathbf{n} \to (1 + X)\) is defined as</p>

\[f(\phi) \defeq \begin{cases}
\phi(m) &amp; \text{if there exists a unique } m \in \mathbf{n} \text{ such that } \phi(m) = (1, x) \text{ for some } x \\
(0,\ast) &amp; \text{otherwise}
\end{cases}\]

  <p>and \(\pi_1 : (1 + X)^\mathbf{n} \times \mathit{In} \to \mathit{In}\) is the second projection function</p>

\[\pi_1(\phi, i) \defeq i\]
</blockquote>

<figure>
<img src="/assets/images/gameloop/mux.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 9</figcaption>
</figure>

<p>Similar to \(\mathit{demux}\), we typically infer the \(\mathit{In}\) argument.</p>

<figure>
<img src="/assets/images/gameloop/mux-postcompose.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 10</figcaption>
</figure>

<h1 id="tic-tac-toe">Tic-tac-toe</h1>

<p>Now we use the dynamical system techniques described above to model the game of tic-tac-toe.
We do not model any notion of a winning condition, but instead focus on the evolution of the game over time, where two agents (players) influence the environment (the board) by submitting moves in a turn-based fashion.</p>

<h2 id="overview-1">Overview</h2>

<p>To model the board, we first need a notion of cell locations. Let each bold natural number
\(\mathbf{n}\) denote the set of natural numbers less than it, i.e.
\(\mathbf{n} \defeq \{ 0, 1, \ldots, n-1 \}\). A location on a tic-tac-toe board consists of an
x-coordinate and a y-coordinate, so we define the set \(\mathit{Loc}\) of locations as</p>

\[\mathit{Loc} \defeq \mathbf{2} \times \mathbf{2}\]

<p>We name the two players Player 0 and Player 1. Elements of the set \(\mathit{Players}\) identify players</p>

\[\mathit{Players} \defeq \{ 0, 1 \}\]

<p>In a typical game of tic-tac-toe, the players use the symbols \(X\) and \(O\) to mark their cells. In our version of tic-tac-toe each player uses its own symbol, either \(0\) or \(1\) to mark cells. An unmarked cell holds the symbol \(\_\). We let \(\mathit{Sym}\) denote the set of possible symbols at a cell:</p>

\[\mathit{Sym} \defeq \{ 0, 1, \_ \}\]

<p>The state of the board is then the set of functions from locations to symbols. We thus define the set of possible board states \(\mathit{Board}\) as</p>

\[\mathit{Board} \defeq \mathit{Sym}^\mathit{Loc}\]

<p>The dynamical system underlying our tic-tac-toe game stepper is then depicted as follows:</p>

<figure>
<img src="/assets/images/gameloop/tictactoe-full.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 11</figcaption>
</figure>

<p>It contains three yet undefined stateful subsystems: \(\mathit{Player0}\), \(\mathit{Player1}\), and \(\mathit{Environment}\). Intuitively, the game stepper advances in a periodic pattern consisting of steps of four types, in order:</p>

<ul>
  <li>\(\mathit{Environment}\) receives a move from \(\mathit{Player0}\) and executes its move</li>
  <li>\(\mathit{Environment}\) submits the resulting board to \(\mathit{Player1}\)</li>
  <li>\(\mathit{Environment}\) receives a move from \(\mathit{Player1}\) and executes its move</li>
  <li>\(\mathit{Environment}\) submits the resulting board to \(\mathit{Player0}\)</li>
</ul>

<p>In sets of the form \(1 + X\), the \(1\) component on the left is typically used to mean “inactive”. For example, on turns in which \(\mathit{Player0}\) submits its move, and on turns in which the environment submits the board to a player, \(\mathit{Player1}\) outputs \((0,\ast)\). Likewise, when \(\mathit{Environment}\) submits a board to \(\mathit{Player0}\), the demultiplexor outputs \((0, \ast)\) along the bottom channel leading to \(\mathit{Player1}\).</p>

<p>Note that players can submit any location to the environment as a move. However, if the cell at the submitted location is already occupied with either \(0\) or \(1\), then the \(\mathit{Environment}\) will choose not to perform the action and advance control to the next player without changing the board.</p>

<h2 id="environment">Environment</h2>

<p>We now define the \(\mathit{Environment}\) dynamical system. Our first task is deciding its set \(\mathit{State}_{\mathit{Environment}}\) of states. First, each state should convey the current execution step type</p>

\[\mathit{StepType} \defeq \{ \mathit{ReceiveFrom}(0), \mathit{SubmitTo}(1), \mathit{ReceiveFrom}(1), \mathit{SubmitTo}(1), \mathit{IllegalState} \}\]

<p>The \(\mathit{IllegalState}\) element above should be used when \(\mathit{Environment}\) receives an invalid input combination (i.e. one which have prevented it from receiving by design). For those familiar with digital logic, this is somewhat analogous to a “don’t care” value.</p>

<p>Additionally, the state should convey the current board. We’ve already defined the set \(\mathit{Board}\) of board states above. Hence, our full state set is defined as</p>

\[\mathit{State}_{\mathit{Environment}} \defeq \mathit{StepType} \times \mathit{Board}\]

<p>As figure 11 shows, the environment’s output set is</p>

\[\mathit{Out}_{\mathit{Environment}} \defeq (1 + \mathit{Board}) \times \mathbf{3}\]

<p>The environment’s \(\mathit{output}_\mathit{Environment} : \mathit{State}_{\mathit{Environment}} \to \mathit{Out}_{\mathit{Environment}}\) function is then defined as</p>

\[\mathit{output}_\mathit{Environment} : \mathit{StepType} \times \mathit{Board} \to (1 + \mathit{Board}) \times \mathbf{3}\]

\[\mathit{output}_\mathit{Environment}(t, b) \defeq \begin{cases}
((1, b), n) &amp; \text{ if } t = SubmitTo(n) \\
((0, \ast), 2) &amp; \text{ if } t = ReceiveFrom(n)
\end{cases}\]

<p>Consulting figure 11, we see that</p>

\[\mathit{In}_{\mathit{Environment}} \defeq 1 + \mathit{Loc}\]

<p>For \(b \in \mathit{Board}\), we define \(b[\ell \mapsto n] \in \mathit{Board}\) as follows.</p>

\[b[\ell \mapsto n](k) \defeq \begin{cases}
b(k) &amp; \text{if } k \neq \ell \\
b(n) &amp; \text{if } k = \ell
\end{cases}\]

<p>We define \(\mathit{nextState}_{\mathit{Environment}} : \mathit{In}_{\mathit{Environment}} \times \mathit{State}_{\mathit{Environment}} \to \mathit{State}_{\mathit{Environment}}\) as
\(~\\\)
\(\mathit{nextState}_{\mathit{Environment}} : (1 + \mathit{Loc}) \times \mathit{StepType} \times \mathit{Board} \to \mathit{StepType} \times \mathit{Board}\)
\(\mathit{nextState}_{\mathit{Environment}}((1,\ell), ReceiveFrom(n), b) \defeq \begin{cases}
(SubmitTo((n+1)~\%~2), b[\ell \mapsto n]) &amp; \text{if } b(\ell) = \_ \\
(SubmitTo((n+1)~\%~2), b) &amp; \text{otherwise}
\end{cases}\)
\(\mathit{nextState}_{\mathit{Environment}}((0,\ast), SubmitTo(n), b) \defeq (ReceiveFrom(n), b)\)</p>

<p>and for any other \((z,s,b) \in (1 + Loc) \times \mathit{StepType} \times Board\) we define
\(\mathit{nextState}_{\mathit{Environment}}(z,s,b) \defeq (\mathit{IllegalState}, b)\)</p>

<p>Finally, we define</p>

\[\mathit{Environment} : \vrt{\mathit{State}_{\mathit{Environment}}}{\mathit{State}_{\mathit{Environment}}} \leftrightarrows \vrt{\mathit{In}_{\mathit{Environment}}}{\mathit{Out}_{\mathit{Environment}}} \defeq \vrt{\mathit{nextState_{\mathit{Environment}}}}{\mathit{output}_{\mathit{Environment}}}\]

<h2 id="players">Players</h2>

<p>We define \(\mathit{Player0}\), eliding \(\mathit{Player1}\) as it is essentialy the same.</p>

<p>The state of the player systems can be used for two purposes. First, the state must record a \(Board\) whenever it is received from the environment. That way the player can use the board to compute a move on the next turn. Second, and optionally, a player’s state can serve as its brain by storing information about plan or strategy that the player is currently executing, or by storing an inferred mental model of the opposing player. We will keep things simple and decide moves in a stateless fashion, using only the current state of the board. Hence, we define</p>

\[\mathit{State}_{\mathit{Player0}} \defeq 1 + \mathit{Board}\]

<p>If the player’s state is \((1, b)\) then it has just received board \(b\) from the environment and is expected to submit a move on the next turn. Otherwise, the player’s state is \((0,\ast)\).</p>

<p>We can see from Diagram 11 that</p>

\[\mathit{In}_{\mathit{Player0}} \defeq 1 + \mathit{Board}\]

<p>and</p>

\[\mathit{Out}_{\mathit{Player0}} \defeq 1 + \mathit{Loc}\]

<p>Let \(\phi : \mathit{Board} \to \mathit{Loc}\) be player 0’s “strategy” for deciding a move given the current board; instead of defining it, we leave it as a parameter to the system.</p>

<p>We then define</p>

\[\mathit{output}_{\mathit{Player0}}(x) \defeq \begin{cases}
(0, \ast) &amp; \text{if } x = (0, \ast) \\
(1, \phi(b)) &amp; \text{if } x = (1, b)
\end{cases}\]

<p>and</p>

\[\mathit{nextState}_{\mathit{Player0}}((1, b), x) \defeq (1, b)\]

\[\mathit{nextState}_{\mathit{Player0}}((0, \ast), x) \defeq (0, \ast)\]

<p>The \(\mathit{Player0}\) dynamical system is then defined as</p>

\[\mathit{Player0} : \vrt{\mathit{State}_{\mathit{Player0}}}{\mathit{State}_{\mathit{Player0}}} \leftrightarrows \vrt{\mathit{In}_{\mathit{Player0}}}{\mathit{Out}_{\mathit{Player0}}} \defeq \vrt{\mathit{nextState}_{\mathit{Player0}}}{\mathit{output}_{\mathit{Player0}}}\]

<h2 id="putting-things-together">Putting things together</h2>

<p>Now that all of the components of our system have been defined, we will wire them together using the lens composition technique, expressing the system as a whole as a mathematical expression.</p>

<p>As a first step, we note that our system can be obtained by wiring together the two dynamical systems named \(A\) and \(B\) displayed below.</p>

<figure>
<img src="/assets/images/gameloop/tictactoe-full-ab.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 12</figcaption>
</figure>

<p>Where</p>

\[A \defeq \mathit{mux}(\mathit{Move}, 2) \circ (\mathit{Player0} \otimes \mathit{Player1})\]

<p>and</p>

\[B \defeq \mathit{demux}(\mathit{Board}, 2) \circ \mathit{Environment}\]

<p>Next, we take their parallel product \(A \otimes B\), which is depicted below.</p>

<figure>
<img src="/assets/images/gameloop/AB-juxtapose.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 13</figcaption>
</figure>

<p>Finally, to close off our system, we must wire together the two components using lens composition, similar to how we wired together the \(\mathit{Clock}\) and \(\mathit{Meridiem}\) systems above.</p>

<p>We use the wiring lens</p>

\[\vrt{w^\sharp}{w} : \vrt{(1 + \mathit{Board}) \times (1 + \mathit{Board}) \times (1 + \mathit{Loc})}{(1 + \mathit{Loc}) \times (1 + \mathit{Board}) \times (1 + \mathit{Board})} \leftrightarrows \vrt{1}{1}\]

<p>where</p>

\[w(\ell, b_0, b_1) \defeq \ast\]

<p>and</p>

\[w^\sharp(\ell, b_0, b_1, \ast) \defeq (b_0, b_1, \ell)\]

<p>Or complete system is then equal to:</p>

\[\vrt{w^\sharp}{w} \circ (A \otimes B)\]

<h1 id="conclusion">Conclusion</h1>

<h2 id="evaluating-the-dynamical-systems-formalism">Evaluating the Dynamical Systems Formalism</h2>

<p>It’s worth taking a step back to ask whether the lens-based dynamical systems formalism is an appropriate tool for modelling turn-based computer games. The ability of lenses to represent cyclic data flow, from the players to the environment and back to the players, is essential. Additionally, lens based dynamical systems make it easy for us to encapsulate data, restricting a players to mutate only their own mental state, and restricting the environment to only mutate the physical world.</p>

<p>One drawback is that, due to the inherently concurrent nature of lens-based dynamical systems, we’ve needed to insert machinery for synchronization, which has little to do with dynamics of our turn-based games. For example, giving most wires the type \(1 + X\) is a distraction.</p>

<h2 id="looking-ahead">Looking ahead</h2>

<p>Now that we’ve developed a mathematical model of a game stepper for tic-tac-toe, let’s recall the significant features listed at the end of my <a href="/posts/2025/07/11/towards-mathematical-model.html">previous post</a> and consider how well the model implements these features.</p>

<ul>
  <li>✅ A robot performs physical actions by submitting requests to an environment. The environment decides whether to honor these requests.</li>
  <li>✅ A robot has internal state, but it’s a purely “mental” state that is used to make decisions. Physical properties of the robot are stored in the environment’s internal state.</li>
  <li>❌ A robot may send a message to another robot, which represents information sent along some physical communication medium.</li>
</ul>

<p>Our model implements the first two features. The game board can be seen as the environment, which encapsulates all physical information, namely the contents of every cell on the game board. A player can be seen as a robot; by virtue of being a dynamical systems, it encapsulates its own private data, i.e. mental state.</p>

<p>The last feature, message passing among robots, is not present in the model I described. In a game’s source code, message passing might look similar to the following pseudo-code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// When the player switches off the fuse box, this channel notifies all subscribers.
channel fuse_box_off : 1;

robot roy {
  receives on fuse_box_off;

  state working {

    handler fuse_box_off (_ : 1) = {
      set_state(fix_fusebox);
    }
  }

  state fix_fusebox {
    ...
  }
}

robot fuse_box {
  sends on fuse_box_off;

  state on {
    handler on_player_touch (_ : 1) = {
      send fuse_box_off(*);
      set_state(off);
    }
  }

  state off {
    ...
  }
}
</code></pre></div></div>

<p>Our program starts with a list of channel declarations. A channel declaration includes both a name and the type of messages sent along the channel. In this example, our channel is named <code class="language-plaintext highlighter-rouge">fuse_box_off</code> and has type \(1\), where \(1\) is the type of containing a single information-free value \(\ast\).</p>

<p>Each robot is implemented as a state machine. A robot definition begins with a list of declarations stating which channels the robot may send and receive upon. Next, the robot defines a list of states. These states can declare <em>handlers</em> to provide code that executes when a message is received, and the handlers in turn can issue <code class="language-plaintext highlighter-rouge">send</code> commands, which broadcast values to all of the subscribers of a channel.</p>

<p>Diagramatically, the dynamical system for such a setup might look something like this.</p>

<figure>
<img src="/assets/images/gameloop/fuse_box_example.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Diagram 12</figcaption>
</figure>

<p>We’ve used a new set operation:</p>

<blockquote>
  <p><strong>Definition</strong> Given a set \(X\), the set \(X^★\) is defined as the set of possibly empty lists whose elements are drawn from \(X\):</p>

\[X^★ \defeq \{ [x_1, \ldots, x_n] \mid \forall i \in 1..n. x_i \in X \}\]
</blockquote>

<p>In diagram 12, the ellipse is a <em>broadcaster</em>. Each element of a list received on an incoming wire is duplicated across all outgoing wires. This allows multiple robots to receive a single message sent along a channel.</p>

<p>An outstanding issue is deciding when a robot handles messages. Clearly, we do not want to handle messages immediately after they are sent, as that could lead to an infinite loop of sending and receiving messages. Instead, we will preserve the existing round robin turn-based approach, and have each robot handle all of its pending messages at the beginning of its turn.</p>

<p>A robot’s behavior then corresponds to a function</p>

\[GameState \times X_1^{★} \times \ldots \times X_n^{★} \to Move \times Y_1^{★} \times \ldots \times Y_m^{★}\]

<p>where \(X_1,\ldots,X_n\) are the types of the channels the robot receives on and \(Y_1, \ldots, Y_m\) are the types of the channels the robot sends on. Many issues arise from this, such as which order a robot handles its messages in and how to map between the functions of the above form and robots’ dynamical systems. These will be covered in the next post, which I have not yet written.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[\(\newcommand{vrt}[2]{\left ( \begin{array}{l} #1 \\ #2 \end{array} \right )}\) \(\newcommand{defeq}{\overset{\mathit{def}}{=}}\) \(\newcommand{am}{\text{a.m.}}\) \(\newcommand{pm}{\text{p.m.}}\)]]></summary></entry><entry><title type="html">Towards a Mathematical Model of Computer Games</title><link href="/posts/2025/07/11/towards-mathematical-model.html" rel="alternate" type="text/html" title="Towards a Mathematical Model of Computer Games" /><published>2025-07-11T20:56:48-07:00</published><updated>2025-07-11T20:56:48-07:00</updated><id>/posts/2025/07/11/towards-mathematical-model</id><content type="html" xml:base="/posts/2025/07/11/towards-mathematical-model.html"><![CDATA[<h1 id="seeking-a-mathematical-model-of-computer-games">Seeking a mathematical model of computer games</h1>

<p>Many years ago, I worked in the computer game industry as a gameplay programmer. My intuition was that the languages I used, C++ and Lua, were not suitable for gameplay programming.</p>

<p>There were a few reasons for this. First, not only did C++ and Lua lack in-built notions of space and time, but they also lacked general purpose feautures for reasoning about them. For example, I could represent a 3D vector as an object in C++, but the C++ type system had no means to specify which basis (a.k.a. “coordinate system”) the vector belonged to, making it easy to perform the invalid operation of adding two vectors belonging to different bases. Second, despite game characters dynamically adjustinging their goals in response to stimulus from their environment, C++ and Lua had no in-built notion of things like imperfect perception and goal setting.</p>

<p>It would be fallacious to claim that the above features are better off built in to a language instead of implemented using general purpose features. In most mainstream langauges, we can implement some sort of state machine system for controlling game characters, where each state represents a distinct goal that a character is persuing. We <em>could</em> tag each vector with a basis identifier, and tag each point with its affine frame, dynamically enforcing proper usage at runtime. Perhaps we could even use some sort of indexed type system to enforce proper vector operations statically, though I’m not sure if any mainstream languages are capable of this.</p>

<p>Nonetheless, I think it’s worth experimenting with the design of game specific languages. Even if it turns out that the abstractions of general purpose languages are sufficient for game specific needs, our game specific experimentation may clarify exactly what is needed and how it should be structured.</p>

<p>There are a few ways we could go about experimenting with game specific languages:</p>

<ul>
  <li>
    <p>Implement a real game specific language that compiles to executable games. This would require an enormous amount of work. We would evaluate our experiment by using our language to create games. This too would require an enormous amount of work. The iteration time for this approach is simply too lengthy to be an effective form of experimentation.</p>
  </li>
  <li>
    <p>Model computer games, or simplified approximations of computer games, as mathematical objects. Then design a language that compiles to such mathematical objects. Evaluate our language by designing a logical system to reason about the game models. If this logic is expressive, we evaluate the language positively, because it implies that humans can reason about it easily.</p>
  </li>
</ul>

<p>The first approach has the advantage of being real, while the second approach provides deeper understanding and faster iteration times. In this post, I’m going to persue the second approach, but I’m only going to take the first step: <strong>I will model computer games, or simplified approximations of computer games, as mathematical objects.</strong> I’ve never created mathematical models of computer games before, so I’m going to try modelling some of the simplest games I can find that still features space, time, and interacting agents. To this end, I’ve chosen to use a 90s game creation system called <em>MegaZeux</em> as an inspiration for my model. The convenient thing about MegaZeux is that, despite feeling like a standard real-time computer game, its time and space are discrete and can therefore be modeled entirely by integers rather than floating point numbers. I will present my model using elementary mathematics; it should be accessible to anyone who knows what sets and functions are.</p>

<h1 id="understanding-the-problem">Understanding the problem</h1>

<p>This post is going to analyze MegaZeux using intuition rather than rigor, trying to isolate the essence of what a MegaZeux game is. It will specifically focus on how multiple simulated agents interact with other agents and the game world, identifying some fundamental features of gameplay programming by exploring a concrete scenario in a MegaZeux game called <em>Weirdness</em>.</p>

<p>This primary purpose of this post is to motivate my next one, in which I create a mathematical model of a MegaZeux-style computer game. However, it might also be a fun read for people who are interested in computer games and have never heard of MegaZeux, or MegaZeux fans who want to consider the system from an analytical perspective.</p>

<h2 id="megazeux">MegaZeux</h2>

<p><em>MegaZeux</em> is a game creation system from the 90s, whose games take place on a grid of 8x14 pixel images. That’s right: in a typical MegaZeux game, every significant object, whether a goblin, a wall, or a tree, is depicted using an 8x14 image. This extreme constraint comes from DOS text-mode graphics, where textual documents were displayed in grids of 8x14 pixel characters. While 8x14 might be a reasonable size to depict a single letter of the Roman alphabet, depicting something more complex, like a human, is much more challenging. As a result, players do not expect the graphics of a MegaZeux game to look good. For a game developer, depicting a game world using simple abstract art rather than poring over complex visual details greatly reduces the effort used to bring a game world to life.</p>

<p>In MegaZeux, scriptable game characters are idosyncratically called <em>robots</em>. However, we will often refer to them as agents. Each robot is controlled by a <em>robotic script</em>. Because robotic scripting is not the state of the art in game character scripting, I will intentionally avoid discussing it comprehensively. I care about what robotic scripting accomplishes rather than how robotic scripting works.</p>

<p>Here are a few examples of Megazuex games:</p>

<p><img src="/assets/images/gameloop/mzx-depot-dungeons.png" /></p>

<p><a href="https://www.digitalmzx.com/show.php?id=2097">Depot Dungeons</a> is a puzzle game where the player must traverse a dungeon while solving puzzles involving lever pulling and crate pushing, while fighting off aggressive mutant cockroaches.</p>

<p><img src="/assets/images/gameloop/mzx-kikan-intro.png" /></p>

<p><a href="https://www.digitalmzx.com/show.php?id=1539">Kikan</a> is a turn based, story driven RPG similar to games in the Final Fantasy series. Unlike most RPGs, it features a semi-realistic modern setting.</p>

<h2 id="roy-a-typical-gameplay-scenario">Roy: A Typical Gameplay Scenario</h2>

<p>It’s extraordinary that MegaZeux was created by a high school kid, Alexis Janson. In addition to creating <em>MegaZeux</em>, she used <em>MegaZeux</em> to create the <em>Zeux</em> series of action adventure games. Then, she created her final <em>MegaZeux</em> game, <em>Weirdness</em>. <em>Weirdness</em> is a puzzle adventure that pushes <em>MegaZeux</em> scripting system to its limits, featuring complex character behaviors and even a first-person maze.</p>

<p>A typical game scripting scenario can be found at the beginning of <em>Weirdness</em>. A character named Roy sits at his computer in his house. If the player touches him, he says “Not now, Jace, I’m busy making UltraZeux games”.</p>

<p><img src="/assets/images/gameloop/mzx-weirdness-roy-computer.png" /></p>

<p>If the player goes into the basement, he can turn off the fuse box, causing the lights in the house to shut off and destorying Roy’s UltraZeux work.</p>

<p><img src="/assets/images/gameloop/mzx-weirdness-fusebox-off.png" /></p>

<p>Roy then walks into the basement and turns the fuse box back on.</p>

<p><img src="/assets/images/gameloop/mzx-weirdness-fusebox-on.png" /></p>

<p>In this scenario, the fuse box itself is a robot. Each robot has a <em>robotic script</em>, which is a program pairing several <em>labels</em>, which are names of events to respond to, with <em>handlers</em>, which are sequences of instructions that the robot should execute in response to these events. When the player attempts to move into the grid cell occupied by the fuse box, the game triggers the fuse box script’s “touch” handler, which spawns a dialog asking the player if they want to turn the fuse box off. If they choose “yes” then another handler inside the fuse box’s script is executed. This handler sends a “fuse box off” message to Roy. Upon receiving the “fuse box off” message, Roy’s robotic script causes him to expresses his frustration and walk into the basement to turn the fuse box back on.</p>

<p>Let’s take a step back and think about what’s going on here, using intuition rather than deep analysis. <em>MegaZeux</em> is simulating the physical world in a rough manner. The robots in this scenario, Roy and the fuse box, represent physical things in the world. Robotic scripts are an abstraction of the physical things’ “brains”: both actual brains, as in the case of Roy, and pseudo brains, as in the case of the fuse box. A pseudo brain is a subset of a physical object’s characteristics that determines how the object interacts with other objects. In the case of the fuse box, its switch might be part of its pseudo brain, but not its metal case.</p>

<p>Each handler in a robotic script issues commands instructing its robot to interact with the world in various ways. For example, <code class="language-plaintext highlighter-rouge">go SOUTH</code> instructs the robot Roy to attempt walking to the grid cell whose \(y\)-coordinate is one greater than Roy’s current \(y\)-coordinate. This will only happen if the cell to the south of Roy is currently unoccupied. For this reason, we can view commands such as <code class="language-plaintext highlighter-rouge">go SOUTH</code> as a message sent from Roy’s brain to the physical world, which we will call the <em>environment</em>. Upon receiving the message, the environment may or may not choose to move Roy, depending on whether such movement is compatible with its laws of physics, which are <em>dictated by the environment</em>.</p>

<p>From this discussion, we extract some key features we would like to model.</p>
<ul>
  <li>Robots that affect the physical world by making requests to an environment. The environment may or may not honor these requests at its discretion.</li>
  <li>A specific type of request a Robot can make to the environment is <em>message sending</em> to another agent, as when the fuse box sends the “fuse box off” message to Roy</li>
  <li>Agents receive messages from the environment and other agents; these message may affect their behavior. The environment can be viewed as a mediator, so that all messages received by robot \(B\) from robot \(A\) can be viewed as coming directly from the environment and indirectly from robot \(B\).</li>
</ul>

<h1 id="computer-games-as-dynamical-systems">Computer games as dynamical systems</h1>

<p>Now that we’ve highlighted the features that we wish to focus on modelling by taking inspiration from <em>MegaZeux</em> and <em>Weirdness</em>, let’s consider the structure of a computer game.</p>

<figure>
<img src="/assets/images/gameloop/game-system.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Diagram 1</figcaption>
</figure>

<p>We can view the game’s state as encapsulated in the game stepper; nothing outside of the game stepper may modify its internal state. The game evolves over a sequence of discrete time steps. At each time step, the game stepper must compute two quantities.</p>

<ul>
  <li>From the game’s current state, the game stepper must compute its output, a matrix of color values to display to the screen.</li>
  <li>The game stepper must also compute the game’s next state from its input and its current state.  Its input might be a mapping from key identifiers to booleans indicating whether each key is pressed. The game’s state might contain a matrix of physical locations, where each location contains an identifier denoting either a game character, a wall, or an empty space.</li>
</ul>

<p>Put differently, the game stepper is a pair of two functions</p>

\[\mathit{output} : \mathit{GameState} \to \mathit{Output}\]

<p>and</p>

\[\mathit{nextState} : \mathit{Input} \times \mathit{GameState} \to \mathit{Output}\]

<p>Such a system is called <em>open</em>, because the source of the \(\mathit{Input}\) wire and the destination of the \(\mathit{Output}\) wire are left unspecified.</p>

<p>Computing the \(\mathit{output}\) function is often called <em>computer graphics</em>.
From the discussion above, you may have inferred that computer graphics is not what I’m interested in, nor am I interested in processing the input. The perspective I’d like to take on computer games actually looks more like this:</p>

<figure>
<img src="/assets/images/gameloop/game-closed-system.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Diagram 2</figcaption>
</figure>

<p>Without input or output, what we have is more of a closed simulation than a game. Now, at each time step, the game stepper no longer computes an output. It still must compute a next state. But because it no longer receives input, only its current state is used to compute its next state. So this diagram depicts a function from game states to game states.</p>

\[\mathit{nextState} : \mathit{GameState} \to \mathit{GameState}\]

<p>Let \(1\) be the singleton set \(\{ \ast \}\), where \(\ast\) is some non-descript set element.
A closed simulation is essentially just a special case of an open one, where both \(\mathit{Input}\) and \(\mathit{Output}\) are equal to the set \(1\).</p>

\[\mathit{output} : \mathit{GameState} \to 1\]

<p>and</p>

\[\mathit{nextState} : 1 \times \mathit{GameState} \to \mathit{GameState}\]

<p>The idea here is that computing an output in the set \(1\) is equivalent to not computing an output at all, because choosing an element of a one-element set does not involve making a decision. Likewise an element of \((\ast, s)\) of \(1 \times \mathit{GameState}\) is equivalent to \(s\) since \(\ast\) is the only choice for the first component of the pair.</p>

<p>A box doesn’t seem very interesting as a diagram. It becomes interesting when we compose it from stateful subcomponents. Each subcomponent is a dynamical system that transforms its current state into output, and also transforms input and an internal state into a next internal state at each point in a sequence a time steps.</p>

<p>What are the stateful subcomponents? As a first approximation, they are</p>

<ul>
  <li>The environment, whose state consists of the grid of available and occupied cells</li>
  <li>The robots. The internal state of the fuse box may track whether it is on or off. The internal state of Roy may contain a program counter that determines which of the instructions such as <code class="language-plaintext highlighter-rouge">go SOUTH</code> or <code class="language-plaintext highlighter-rouge">go EAST</code> he will perform at the next time step.</li>
</ul>

<p>Note that the position of each robot is part of the simulated “physical world” and is thus contained in the internal state of the environment rather than the internal state of the robot itself. This is why a robot can only make a <em>request</em> to move to an adjacent grid cell, and it is ultimately the environment’s decision whether or not to honor that request.</p>

<h1 id="conclusion">Conclusion</h1>

<p>We’ve examined MegaZeux’s <em>robot</em> system, which is used to define complex objects, both sentient and non-sentient, interacting in a simulated world. Some notable features are:</p>

<ul>
  <li>A robot performs physical actions by submitting requests to an environment. The environment decides whether to honor these requests.</li>
  <li>A robot has internal state, but it’s a purely “mental” state that is used to make decisions. Physical properties of the robot are stored in the environment’s internal state.</li>
  <li>A robot may send a message to another robot, which represents information sent along some physical communication medium.</li>
</ul>

<p>In my next post, I will define a game stepper for tic-tac-toe, which resembles MegaZeux in a few different ways</p>

<ul>
  <li>The environment is the game board.</li>
  <li>The two players, like robots, submit requests to the environment. Their internal state can be used for planning and decision making, but is isolated from the physical rules of the game board.</li>
</ul>

<p>Just for fun, I will leave you with the source code for the robot Roy from Weirdness. Reading it is optional. It demonstrates what I’m trying to avoid. The code that controls a robot or agent should communicate intent to the reader. Its evolution over time and interactions with the world should be formally summarizable with assertions. It should provide high level constructs to perform complex tasks simply. Implementing Roy using a modern state machine or behavior tree system would improve things in this direction, but by having a mathematical model of the agents and the environment they interact with, I think we can improve things even more.</p>

<details>
<summary>Roy's Robotic Script (Click to expand)</summary>
<p style="white-space:pre-line;background-color:lightgray;">: "do"
set "loopcount" to random 140 to 142
char "loopcount"
wait for 2
goto "do"
: "touch"
* "~5Roy: Not now, Jace, I'm busy making UltraZeux games."
send "msg" to "fad"
goto "do"
: "fboff"
lockself
char 'ç'
wait for 25
* "~5Roy: $%#&amp;&amp;*! I haven't saved my game yet!"
send "msg" to "fad"
: "fboff2"
wait for 45
char 'á'
cycle 2
* "~5Roy: I'd better go check the fuse box..."
send "msg" to "fad"
go SOUTH for 3
: "mv1r"
if touching SOUTH then "mv1"
go SOUTH for 1
go WEST for 2
: "mv2r"
if touching WEST then "mv2"
go WEST for 1
: "dr1r"
if c?? Space p?? at WEST then "dr1"
if touching WEST then "mvx5"
open at WEST
wait for 1
color c8e
go WEST for 4
go SOUTH for 8
rel to self
: "mv4r"
if player at 222 -12 "mv4"
rel to self
gotoxy 222 -12
go SOUTH for 7
go WEST for 12
: "dr2r"
if c?? Space p?? at NORTH then "dr2"
if touching NORTH then "mvx6"
open at NORTH
wait for 1
go NORTH for 4
go EAST for 6
: "mv5r"
if touching EAST then "mv5"
go EAST for 1
rel to self
: "mv6r"
if player at 74 0 "mv6"
rel to self
gotoxy 74 0
go WEST for 11
: "mv7r"
if touching WEST then "mv7"
go WEST for 1
wait for 10
if "darkness" = 0 then "noprob"
if "wire" = 1 then "nowire"
* "~5Roy: Ahh, here's the problem."
send "msg" to "fad"
wait for 10
send at WEST to "fix"
wait for 5
: "noprobr"
go EAST for 11
: "mv8r"
if touching EAST then "mv8"
go EAST for 1
rel to self
: "mv9r"
if player at -74 0 "mv9"
rel to self
gotoxy -74 0
go WEST for 7
: "mvx1r"
if touching SOUTH then "mvx1"
go SOUTH for 1
: "mvx2r"
if touching SOUTH then "mvx2"
: "dr4r"
if c?? OpenDoor p?? at SOUTH then "dr3"
rel to self
if c?? OpenDoor p?? at -1 1 then "dr4"
go SOUTH for 1
put c0f Door p04 to SOUTH
open at SOUTH
wait for 1
go SOUTH for 2
if "tostore" = 1 then "toss"
go EAST for 12
go NORTH for 7
rel to self
: "mvBr"
if player at -222 12 "mvB"
rel to self
gotoxy -222 12
go NORTH for 7
: "mvCr"
if touching NORTH then "mvC"
go NORTH for 1
: "mvx3r"
if touching EAST then "mvx3"
go EAST for 1
: "mvx4r"
if touching EAST then "mvx4"
: "dr6r"
if c?? OpenDoor p?? at EAST then "dr5"
rel to self
if c?? OpenDoor p?? at 1 1 then "dr6"
go EAST for 1
put c0f Door p03 to EAST
open at EAST
color c1e
wait for 1
go EAST for 5
go NORTH for 4
cycle 1
send "dthing" to "check"
unlockself
if "darkness" = 1 then "fboff2"
goto "do"
: "mvx1"
cycle 1
move player to EAST
cycle 2
goto "mvx1r"
: "mvx2"
cycle 1
move player to EAST
cycle 2
goto "mvx2r"
: "mvx3"
cycle 1
move player to SOUTH
cycle 2
goto "mvx3r"
: "mvx4"
cycle 1
put player SOUTH
cycle 2
goto "mvx4r"
: "mvx5"
cycle 1
put player EAST
cycle 2
goto "dr1"
: "mvx6"
cycle 1
put player SOUTH
cycle 2
goto "dr2"
: "dr1"
rel to self
put c01 Floor p?? at -2 0
rel to self
put c01 Floor p?? at -2 1
put c0f Door p05 to WEST
goto "dr1r"
: "dr2"
rel to self
put c04 Floor p?? at 0 -2
rel to self
put c04 Floor p?? at -1 -2
put c0f Door p00 to NORTH
goto "dr2r"
: "dr3"
: "dr4"
rel to self
put c04 Floor p?? at -1 1
put c04 Floor p?? to SOUTH
rel to self
put c0f Door p04 at 0 2
goto "dr4r"
: "dr5"
: "dr6"
rel to self
put c01 Floor p?? at 1 1
put c01 Floor p?? to EAST
rel to self
put c0f Door p03 at 2 0
goto "dr6r"
: "mv1"
cycle 1
move player to EAST
cycle 2
goto "mv1r"
: "mv2"
cycle 1
move player to NORTH
cycle 2
goto "mv2r"
: "mv4"
cycle 1
move player to WEST
cycle 2
goto "mv4r"
: "mv5"
cycle 1
move player to SOUTH
cycle 2
goto "mv5r"
: "mv6"
cycle 1
move player to NORTH
cycle 2
goto "mv6r"
: "mv7"
cycle 1
move player to NORTH
cycle 2
goto "mv7r"
: "mv8"
cycle 1
move player to NORTH
cycle 2
goto "mv8r"
: "mv9"
cycle 1
move player to SOUTH
cycle 2
goto "mv9r"
: "mvB"
cycle 1
move player to WEST
cycle 2
goto "mvBr"
: "mvC"
cycle 1
move player to WEST
cycle 2
goto "mvCr"
: "noprob"
* "~5Roy: Hmmm... nothing wrong here."
send "msg" to "fad"
wait for 15
goto "noprobr"
: "nowire"
* "~5Roy: Is this somebody's idea of a joke!?"
send "msg" to "fad"
wait for 15
* "~5Roy: I guess I'll go buy a new wire..."
send "msg" to "fad"
wait for 5
set "tostore" to 1
goto "noprobr"
: "toss"
go SOUTH for 3
: "ts1r"
if touching SOUTH then "ts1"
go SOUTH for 1
* "~5Roy: I'll be back later, Jace, DON'T touch my computer!"
send "msg" to "fad"
send "dthing" to "check"
set "tostore" to 0
die
: "ts1"
cycle 1
move player to EAST
cycle 2
goto "ts1r"
</p>
</details>

<hr />

<p><strong>Next:</strong> <a href="/2025/10/18/modelling-tic-tac-toe.html">Modelling Tic-Tac-Toe</a></p>]]></content><author><name></name></author><category term="posts" /><summary type="html"><![CDATA[Seeking a mathematical model of computer games]]></summary></entry></feed>