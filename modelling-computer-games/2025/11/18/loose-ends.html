<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css">
  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Kevin Clancy" />

</head>
<body>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header-classic">
    <h1 class="post-title p-name" itemprop="name headline">Loose Ends and Future Directions</h1>
    <p class="post-meta"><time class="dt-published" datetime="2025-11-18T08:00:00-08:00" itemprop="datePublished">
        Nov 18, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>\(\newcommand{vrt}[2]{\left ( \begin{array}{l} #1 \\ #2 \end{array} \right )}\)
\(\newcommand{defeq}{\overset{\mathit{def}}{=}}\)</p>

<h1 id="brain-dump">Brain Dump</h1>

<p>In this series, I‚Äôve explored how to model computer games using dynamical systems and lenses: starting with <a href="/modelling-computer-games/2025/07/11/towards-mathematical-model.html">motivational foundations</a>, then <a href="/modelling-computer-games/2025/10/18/modelling-tic-tac-toe.html">formalizing tic-tac-toe</a>, and most recently <a href="/modelling-computer-games/2025/11/04/modelling-megazeux.html">modelling MegaZeux-style games</a> with robots moving on grids.</p>

<p>I‚Äôve become exhausted working on this project for now. It‚Äôs not the sort of thing that will help me get a job, so I‚Äôm going to try to record all of the unsolidified ideas I‚Äôve been thinking about in this post. I‚Äôm going to try my best to keep it scrutable, but because it is a brain dump, expect it to be somewhat disconnected.</p>

<h1 id="loose-ends">Loose Ends</h1>

<p>I‚Äôve had a few small ideas about these game models that I haven‚Äôt gotten around to describing. They‚Äôre relevant to the self-critique below, so I‚Äôll describe them here.</p>

<h2 id="player-as-robot">Player as Robot</h2>

<p>In my first post, I mentioned that I wanted to analyze games as <em>closed</em> dynamical systems, i.e. systems which are not influenced by input and which do not produce any output. These systems are more simulations than games. Since closed systems do not take input, does that mean they cannot model the notion of a <em>player</em>, a robot modelling a sentient being whose actions are driven by external input?</p>

<p>If we‚Äôre using possibilistic dynamic systems, then the answer is no. In possibilistic systems, it is extremely simple to model a player using a robot. A player can be modeled as a robot whose \(\mathit{nextState}\) function produces the set of all possible successor states paired with all possible action submissions.</p>

<h2 id="robot-input-as-observations">Robot Input as Observations</h2>

<p>In <a href="/modelling-computer-games/2025/11/04/modelling-megazeux.html">Modelling MegaZeux</a>, every robot receives the full board state as input at every frame. This means that every robot is omniscient. Hence, a robot somehow knows where every other robot is, even if they are separated from it by a wall. To gain some realism, we could modify the environment to only send a robot the positions of those robots and walls within its line of sight.</p>

<p>This isn‚Äôt to say that giving robots omniscient perception is always undesirable. But just that in many games, players expect robots to
perceive realistically, and so in the general case each individual robot should perceive only a strict subset of the complete game state.</p>

<h1 id="fine-state-vs-coarse-state">Fine State vs Coarse State</h1>

<p>In <a href="/modelling-computer-games/2025/07/11/towards-mathematical-model.html">my first post</a>, I awkwardly noted that a robotic script performs the role of a robot‚Äôs brain. I pointed out that while the fuse box is implemented as a robot, the real world object that it simulates (a fuse box) is not an animal and therefore does not have a brain. But the fuse box does have physical characteristics, such as a boolean flag indicating whether it is on or off, that is both beyond the scope of the MegaZeux game engine‚Äôs capacity to understand and relevant to how it interacts with the other objects in the game world.</p>

<p>We can think of the physical properties within the scope of the game engine as <em>coarse grained</em>. A robot‚Äôs cell position in the game world‚Äôs grid is the only coarse grained physical property that we have discussed so far. Physical properties that fall outside the scope of the game engine, such as the on/off position of the fuse box, can only be read and written by custom scripts. We can think of these properties as <em>fine grained</em>.</p>

<p>Game logic consists of <em>scripts</em> acting on <em>data</em>. All scripts are inherently fine grained, because they are written by a game developer for a specific game; they are not part of the engine and do not describe behavior that is generic across all games. Data can be fine grained or coarse grained; the mental states described in <a href="/modelling-computer-games/2025/11/04/modelling-megazeux.html">modeling MegaZeux-style games</a> are fine grained, while robot positions are coarse grained.</p>

<p>A robot that simulates a sentient being could have additional fine grained state beyond its mental state. For example, the fine grained state of a swordsman may include a boolean flag indicating whether or not his sword is drawn. In the game Weirdness, described in <a href="/modelling-computer-games/2025/07/11/towards-mathematical-model.html">my first post</a>, the player maintains a large inventory of items. This too could be considered fine grained state.</p>

<p>From the above discussion, I conclude that ‚Äúpseudo brain‚Äù and ‚Äúmental state‚Äù are confused terminology that must be retired immediately. From now on, the mental states \(\Sigma_i\) discussed in <a href="/modelling-computer-games/2025/11/04/modelling-megazeux.html">modeling MegaZeux-style games</a> shall be referred to as <em>fine states</em>. Physical properties such as robot positions, which fall within the scope of the game engine (and were conveyed by elements of \(\mathit{BoardState}\) in modelling MegaZeux), shall be referred to as <em>coarse state</em>.</p>

<p>The following table summarizes these concepts:</p>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>Granularity</th>
      <th>Managed By</th>
      <th>Examples</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Coarse State</strong></td>
      <td>Coarse-grained</td>
      <td>Game engine</td>
      <td>Robot positions, wall locations, tile types</td>
    </tr>
    <tr>
      <td><strong>Fine State</strong></td>
      <td>Fine-grained</td>
      <td>Game-specific scripts</td>
      <td>Fuse box on/off flag, player inventory, NPC dialog state</td>
    </tr>
    <tr>
      <td><strong>Scripts</strong></td>
      <td>Fine-grained</td>
      <td>Game developer</td>
      <td>Robot behavior code, custom game logic</td>
    </tr>
  </tbody>
</table>

<h2 id="defining-the-finecoarse-boundary">Defining the Fine/Coarse Boundary</h2>

<p>Placing the boundary between fine and coarse is a pragmatic decision made by the game engine developer; there are no formal restrictions on how it is done. In fact, the table in the previous section is just an example. The designer of MegaZeux (Alexis Janson) could have decided to include an inventory system directly into MegaZeux. Each MegaZeux game would declare a set of items, and during the execution of the game, MegaZeux would associate each robot with the subset of the declared items that it currently possesses. This inventory system would not be pragmatic for most games, because players do not tend to care about what items non-player NPCs possess.</p>

<p>As a side note, MegaZeux does provide a limited coarse inventory system, but just for the player rather than all robots. The game engine tracks the number of gems (which can be used as money) the player possesses, as well as which keys (which can be used to open doors) they possess. This quirky system makes it easy for newcomers to make simple games.</p>

<h1 id="robots-encapsulation-interactions">Robots, Encapsulation, Interactions</h1>

<p>There‚Äôs something else that bothers me about using the term ‚Äúpseudo brain‚Äù in my initial post. The player and the fuse box are completely different types of things. The player simulates a sentient being that can establish goals and affect the world around it. The fuse box is just an object with no cognitive power, which contains fine state but remains static unless acted upon. Why does the fuse box have a script associated with it? Scripts are actions that change the world state, whereas inanimate objects like the fuse box cannot change the world state. When the player touches the fuse box, the fuse box does not decide to change its position and send a message along the ‚Äúfuse box off‚Äù channel; that action is caused by the player.</p>

<p>Perhaps MegaZeux is under-taxonomized. Instead of robots, we could use constructs of a different type to represent inanimate objects with fine state but no behavior; let‚Äôs call this type of construct a <em>widget</em>. When a robot attempts to move into a widget‚Äôs position, a function which performs their interaction should execute. This function should take as parameters both the fine state of the widget and the fine state of the robot, as well as the coarse state that the robot observes on the particular frame that the two objects collide. The function should produce as output a pair of two new states for the widget and robot.</p>

<p>Also consider what happens when one robot attempts to move into a cell that is already occupied by another robot. The environment could send both of the robots a ‚Äútouch‚Äù message, but both robots would need to access the fine state of the other in order to respond properly. One robot may even need to change the fine state of the other, say by knocking a sword out of the other robot‚Äôs hands. Should one robot A‚Äôs touch handler drop its sword in response to a collision, or should robot B‚Äôs handler knock robot A‚Äôs sword from its hands?</p>

<p>This discussion suggests that handling interactions from a first-person perspective is a flawed idea. What we really need is a single interaction handler. This handler could take the fine states and observations of both robots as arguments, and its results should include updated fine states of both robots. Be warned, this line of reasoning is leading to a radical departure from the models I‚Äôve presented so far, as a dynamical system representing a robot can no longer have exclusive access to the robot‚Äôs fine state.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function handle_robot_collision(swordsman_state a, swordsman_state b) : swordsman_state * swordsman_state = {
  match (a,b) with
  | (Drawn, Drawn) -&gt;
     // play clanking sound
    (Drawn, Swordless)
  | (Drawn, Swordless) -&gt;
    (Drawn, Dead)
  | (Drawn, Dead) -&gt;
    (Drawn, Dead)
  | (Swordless, Drawn) -&gt;
    (Dead, Drawn)
  | (Dead, Drawn) -&gt;
    (Dead, Drawn)
}
</code></pre></div></div>

<p>Interactions generally take multiple frames to complete. In the first-person model that I began with, a robot is notified of an interaction by receiving a message. The message handler may then switch the robot to a state intended solely for responding to the message; this state may perform actions over the course of many frames responding to the message. With an interaction handler, we could change states of the involved robots so that they spend several frames responding to the interaction event. But naively, they would do so independently, controlled by separate scripts and without access to each other‚Äôs fine state. Instead, what if a single piece of code, or a single ‚Äúinteraction‚Äù entity, controlled the interaction for several frames? This entity would have access to both robots‚Äô fine states and possibly possess some fine state of its own. It would be similar to a robot but without an associated grid location; let‚Äôs call such entities ‚Äúambient robots‚Äù.</p>

<p>Here is an example of a multi-frame interaction: a dialog between the player and an NPC (non-player character). This dialog is initiated by the player‚Äôs attempt to move into the cell of the NPC. The dialog can‚Äôt be resolved in a single frame, as it requires the player to answer a sequence of questions posed by the NPC. So the interaction handler mutates the player and NPC into ‚Äúacquired‚Äù states in which they stay idle for the duration of the dialog. The ambient robot managing the interaction maintains its own fine state, which simultaneously simulates the mental states of both the player and the NPC. Here is an example of how such an interaction handler might be implemented.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum {
  Buy,
  Sell
}

ambient robot player_npc {

  // reference that provides access to player coarse state, such as portrait image and position
  // shared across all player_npc states
  robot player;

  // reference that provides access to npc coarse state, such as portrait image and position
  // shared across all player_npc states
  robot npc;

  state Inactive {
    // a function to handle the collision immediately
    function player_npc_collide(player_state p, npc_state n) : player_state * npc_state * player_npc_state {
      // First component is player's new state - Acquired means that the player only responds to commands from player_npc robot
      // Second component is npc's new state - Acquired means that it only responds to commands
      // Dialog is the new state for player_npc - its definition is given below
      (Acquired, Acquired, Dialog)
    }
  }

  state Dialog
  {
    // a coroutine that runs the dialog between the two characters
    script run() {
      let choice = npc.ask("Would you like to buy or sell items?", [("Buy", Buy), ("Sell", Sell)]);
      match choice with
      | Buy -&gt;
        player.say("I'd like to buy items.");
        // code for buy user interface here
      | Sell -&gt;
        player.say("I'd like to sell items.");
        // code for sell user interface

      // send the player and npc back into the states they were in before they were acquired
      player.release();
      npc.release();
      set_state(Inactive);
    }
  }
}
</code></pre></div></div>

<p>This ambient robot does not contain fine state that replicates the fine state of the <code class="language-plaintext highlighter-rouge">player</code> and <code class="language-plaintext highlighter-rouge">npc</code> robots. Instead, it describes additional fine state associated with the <code class="language-plaintext highlighter-rouge">player</code> and <code class="language-plaintext highlighter-rouge">npc</code> robots. Its two fields <code class="language-plaintext highlighter-rouge">player</code> and <code class="language-plaintext highlighter-rouge">npc</code> simulate the shared awareness of the two robots‚Äô identities; though <code class="language-plaintext highlighter-rouge">player_npc</code> is a state machine, these fields are shared across both of its states <code class="language-plaintext highlighter-rouge">Inactive</code> and <code class="language-plaintext highlighter-rouge">Dialog</code>. In the <code class="language-plaintext highlighter-rouge">Dialog</code> state, it manages additional fine state: namely, the program counter and the callstack of the <code class="language-plaintext highlighter-rouge">run</code> coroutine. These pieces of information simulate the two characters‚Äô shared understanding of specifics of the dialog. For example, <code class="language-plaintext highlighter-rouge">run</code>‚Äôs callstack may contain the <code class="language-plaintext highlighter-rouge">choice</code> variable, which stores the player‚Äôs choice of whether to buy or sell items.</p>

<h2 id="doubts">Doubts</h2>

<p>The above section has some workable ideas: for example, ambient robots handling interactions over multiple frames would be useful for quickly creating short cinematic sequences. However, giving a single event handler access to multiple robots‚Äô fine states seems too large of a departure from both the framework I‚Äôve designed so far and standard game scripting practice. If I come back to this project, I am going to abandon that particular idea. I‚Äôm still on the fence about distinguishing between widgets and robots.</p>

<p>‚úÖ Ambient robots for multi-frame interactions
‚úÖ Interaction handlers as separate entities
‚ùå Single function accessing multiple robots‚Äô fine states
ü§î Distinguishing widgets from robots</p>

<h1 id="globals-vs-messages">Globals vs messages</h1>

<p>In MegaZeux, fine state is stored in what are called <em>counters</em>. Counters are global integer-valued variables that can be read and written arbitrarily by robotic scripts. Here are some examples of counters used by Weirdness:</p>

<ul>
  <li>The game starts in a house with three sinks. Each time the player turns on a sink, the <code class="language-plaintext highlighter-rouge">sinks</code> counter, which starts equal to 0, is incremented. Below the house is an area with a water stream blocking the path. Upon entering this area, a robot checks if <code class="language-plaintext highlighter-rouge">sinks</code> is equal to three and clears the stream if so.</li>
  <li>The player can interact with the world by applying objects stored in their inventory (a custom fine-state inventory rather than the built-in MegaZeux inventory). Corresponding to each inventory item is a counter that is equal to <code class="language-plaintext highlighter-rouge">1</code> if the player possesses the item and <code class="language-plaintext highlighter-rouge">0</code> otherwise.</li>
</ul>

<p>A central guiding principle for my models has been <em>realism</em>. Because a game is a simulation of the real world, developers expect it to behave like the real world. For example, having all NPC‚Äôs ``act simultaneously‚Äô‚Äô each frame, all responding to stimuli derived from a common world state at a moment in time, is a decision made in appeal to realism.</p>

<p>Global counters are not realistic. In the real world, state is located in space. By associating a piece of fine state with a robot that either has custody of it or shares proximity with it, we make it clear to the developer what state they are likely to manipulate when writing the robot‚Äôs code. Quick interactions between spatially separated objects can be triggered by sending a message along a channel. We therefore do away with global counters, as they are subsumed by the more realistic combination of fine state and message channels. Weirdness would be rewritten in the following way:</p>

<ul>
  <li>Turning a sink on or off sends a boolean message along the <code class="language-plaintext highlighter-rouge">water_pipe</code> channel. When the message arrives at the <code class="language-plaintext highlighter-rouge">stream</code> robot beneath the house, the <code class="language-plaintext highlighter-rouge">stream</code> robot either increments or decrements a fine state integer variable. The waterway ‚Äúdries up‚Äù when the integer variable is incremented to 3.</li>
  <li>The player stores its inventory in its fine state as an element of a set datatype.</li>
</ul>

<h1 id="dynamic-behavior">Dynamic Behavior</h1>

<p>So far, we‚Äôve made references to the state of our models advancing over a discrete sequence of time steps. But we‚Äôve done so informally; we still don‚Äôt have a formal definition of our system‚Äôs behavior. The behavior of a deterministic system could be represented as a sequence of states, i.e. a function of type \(\mathbb N \to \matit{State}\). The way such a behavior is derived from a dynamical system is described in chapter 3 of <em>Categorical Systems Theory</em>. The behavior of a non-deterministic system would probably be the set of all possible state sequences. In Categorical Systems Theory, Myers doesn‚Äôt explore the behavior of non-deterministic systems very far, acknowledging it as a blind spot.</p>

<h1 id="partial-possibilistic-systems">Partial Possibilistic Systems</h1>

<p>In <a href="/modelling-computer-games/2025/11/04/modelling-megazeux.html">modelling MegaZeux-style games</a>, we used possibilistic systems to represent non-deterministic state update. The key feature was that the passback function produced a set of successor states instead of a single successor state</p>

\[\mathit{nextState} : \mathit{State} \times \mathit{In} \to P(\mathit{State})\]

<p>We handled precondition violations by mapping them to the empty set. This is a hack that is bound to cause problems when we try to define dynamic behavior. A more robust and principled approach would be to define a new type of dynamical system that can express both non-determinism and precondition violations. Let \(P_+\) be the <em>non-empty powerset operator</em> which maps a set \(X\) to the set of all non-empty subsets of \(X\). Then our new type of dynamical system, which we could call a <em>partial possibilistic dynamical system</em> would have a passback function of the following form</p>

\[\mathit{nextState} : \mathit{State} \times \mathit{In} \to 1 + P_+(\mathit{State})\]

<p>A state/input pair that violates our system‚Äôs precondition would map to the left component \((0, \ast)\), whereas any state/input pair that satisfies our system‚Äôs precondition would map to a non-empty set of successor states \(X\) in the right component \((1, X)\).</p>

<h1 id="why-im-pausing-this-work">Why I‚Äôm Pausing This Work</h1>

<p>Over a year ago, I fell while going for a run, breaking my jaw and wrist. Immediately afterward, I didn‚Äôt feel capable of doing much other than sitting around and playing video games all day. But I feel terrible if I spend too much time without learning or making things. So as a compromise, I started thinking about the present topic. Now I‚Äôve mostly recovered, and I need to find a new job. Therefore, instead of continuing with this project, I‚Äôm going to spend time learning things that employers are interested in, like web development.</p>

<p>Though it‚Äôs woefully incomplete, I‚Äôm glad that I wrote this series. Rather than just reading Categorical Systems Theory and solving the exercises, I was able to synthesize it into something new, which motivated me to dig in more deeply than I otherwise would have. Who knows? Some day I may return to this project and extend it into an actual game engine.</p>

  </div><a class="u-url" href="/modelling-computer-games/2025/11/18/loose-ends.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          
        </ul>
      </div>
      <div class="footer-col">
        <p></p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
