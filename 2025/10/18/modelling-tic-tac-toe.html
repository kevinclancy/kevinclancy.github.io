<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css">
  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Kevin Clancy" />

</head>
<body>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header-classic">
    <h1 class="post-title p-name" itemprop="name headline">Modelling Tic-Tac-Toe</h1>
    <p class="post-meta"><time class="dt-published" datetime="2025-10-18T09:35:00-07:00" itemprop="datePublished">
        Oct 18, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>\(\newcommand{vrt}[2]{\left ( \begin{array}{l} #1 \\ #2 \end{array} \right )}\)
\(\newcommand{defeq}{\overset{\mathit{def}}{=}}\)
\(\newcommand{am}{\text{a.m.}}\)
\(\newcommand{pm}{\text{p.m.}}\)</p>

<h1 id="overview">Overview</h1>

<p>This post is a continuation of <a href="/posts/2025/07/11/towards-mathematical-model.html">Towards a Mathematical Model of Computer Games</a>. Unlike that post, this one is focused on mathematical rigor rather than motivation. Rather than defining a mathematical model of a MegaZeux game, it pursues the less ambitious goal of defining a mathematical model of tic-tac-toe. The game tic-tac-toe shares some common characteristics with a MegaZeux game.</p>

<p>The game involves two players. Each of these players is analogous to a MegaZeux robot, and the game board plays the role of the environment. The players repeatedly make requests to the board to alter its state. The board may or may not honor those requests depending on whether they obey its “laws of physics”.</p>

<p>The two players together with their environment will form a <em>closed system</em>, i.e. a set \(\mathit{GameState}\) with an update function</p>

\[\mathit{nextState} : \mathit{GameState} \to \mathit{GameState}\]

<p>Or equivalently, a set of two functions, using \(1 = \{ \ast \}\) as both the input and output sets:</p>

\[\mathit{output} : \mathit{GameState} \to 1\]

<p>and</p>

\[\mathit{nextState} : 1 \times \mathit{GameState} \to \mathit{GameState}\]

<p>We will construct this closed system out of open systems such as the players. The players are open systems that take observations of the board state as inputs and produce move choices as outputs. As a rough first approximation, a player can be diagrammed as follows:</p>

<center>
<img src="/assets/images/gameloop/ttt-player.drawio.png" />
</center>

<p>The above system is considered <em>open</em> because its input and output are not one-element sets; they contain actual information that must be received from and sent to unspecified destinations. Each turn, an element of BoardState is received as input. The player uses the current board state, possibly along with the player’s own internal state, to decide a move to submit to the board.</p>

<p>Now, let’s develop a formalism that allows us to compose complex systems from simpler systems.</p>

<h1 id="lenses">Lenses</h1>

<p>We model open systems mathematically using a construct called <em>lenses</em>. I learned about lenses from <a href="https://www.davidjaz.com/Papers/DynamicalBook.pdf">Categorical Systems Theory</a>, which I highly recommend. In the interest of self-containment, I will rehash the fundamentals of lenses now.</p>

<h2 id="definitions">Definitions</h2>

<blockquote>
  <p><strong>Definition</strong></p>

  <p>An <strong>arena</strong> \(\vrt{A^-}{A^+}\) is a pair consisting of two sets \(A^-\) and \(A^+\).</p>
</blockquote>

<blockquote>
  <p><strong>Definition</strong></p>

  <p>A <strong>lens</strong> \(\vrt{f^\sharp}{f} : \vrt{A^-}{A^+} \leftrightarrows \vrt{B^-}{B^+}\) is a pair consisting of two functions:</p>
  <ul>
    <li>A passforward function \(f : A^+ \to B^+\)</li>
    <li>A passback function \(f^\sharp : A^+ \times B^- \to A^-\)</li>
  </ul>

  <p>The arena \(\vrt{A^-}{A^+}\) is called the <strong>domain</strong> of \(\vrt{f^\sharp}{f}\) and the arena \(\vrt{B^-}{B^+}\) is called the <strong>codomain</strong> of \(\vrt{f^\sharp}{f}\).</p>
</blockquote>

<p>The passforward function of a lens can be viewed as sending information “downstream” and the passback function can be viewed as sending information “upstream”. One particularly important type of lens is a discrete dynamical system.</p>

<blockquote>
  <p><strong>Definition</strong></p>

  <p>A <strong>discrete dynamical system</strong> (or <strong>dynamical system</strong> for short) is a lens of the form</p>

\[\vrt{\mathit{nextState}}{\mathit{output}} : \vrt{\mathit{State}}{\mathit{State}} \leftrightarrows \vrt{\mathit{In}}{\mathit{Out}}\]

  <p>That is, a dynamical system is a lens whose domain is an arena of the form \(\vrt{\mathit{State}}{\mathit{State}}\) for some set \(\mathit{State}\).</p>
</blockquote>

<p>Above, we consider \(\mathit{State}\) the type of our dynamical system’s internal state, \(\mathit{In}\) the type of its input, and \(\mathit{Out}\) the type of its output. Expanding the definition of lens, we see that</p>
<ul>
  <li>\(\mathit{nextState} : \mathit{State} \times \mathit{In} \to \mathit{State}\) is a function that takes a pair of a “current” state and an input to a “next” state.</li>
  <li>\(\mathit{output} : \mathit{State} \to \mathit{Out}\) is a function that takes a state to an output.</li>
</ul>

<p>This matches the intuitive structure of game engines that I presented previously. Those familiar with digital logic may know the distinction between <em>Moore machines</em> and <em>Mealy machines</em>. The output of a Mealy machine may depend both on its input and its current state, whereas the output of a Moore machine may only depend on its current state. In this sense, a dynamical system is like a Moore machine rather than a Mealy machine: before its input can affect its output, it must store the input in its state as an intermediate step. This can be a bit awkward sometimes, but it’s not a fundamental problem.</p>

<p>A dynamical system \(S : \vrt{\mathit{State}_S}{\mathit{State}_S} \leftrightarrows \vrt{\mathit{In}_S}{\mathit{Out}_S}\) can be depicted as follows.</p>

<figure>
<img src="/assets/images/gameloop/discrete-dynamical-system.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>
Figure 1
</figcaption>
</figure>

<p>Note that the set \(\mathit{State}_S\) does not appear in the diagram, because it does not affect the systems that \(S\) interacts with.</p>

<p>If the codomain of one lens matches the domain of another then we can compose them together.</p>

<blockquote>
  <p><strong>Definition</strong></p>

  <p>Given lenses \(\vrt{f^\sharp}{f} : \vrt{A^-}{A^+} \leftrightarrows \vrt{B^-}{B^+}\) and
\(\vrt{g^\sharp}{g} : \vrt{B^-}{B^+} \leftrightarrows \vrt{C^-}{C^+}\) their <strong>composite</strong>
\(\vrt{g^\sharp}{g} \circ \vrt{f^{\sharp}}{f}\) is defined as \(\vrt{h^\sharp}{h}\), where</p>

  <ul>
    <li>\(h\) is defined as the function composite \(g \circ f\)</li>
    <li>\(h^\sharp\) is defined such that \(h^\sharp(a^+, c^-) \defeq f^\sharp(a^+, g^\sharp(f(a^+), c^-))\)</li>
  </ul>
</blockquote>

<p>We also have a parallel composition operator on lenses.</p>

<blockquote>
  <p><strong>Definition</strong></p>

  <p>Given two lenses \(\vrt{f^\sharp}{f} : \vrt{A^-}{A^+} \leftrightarrows \vrt{B^-}{B^+}\) and
\(\vrt{g^\sharp}{g} : \vrt{C^-}{C^+} \leftrightarrows \vrt{D^-}{D^+}\) we define their parallel
product
\(\vrt{f^\sharp}{f} \otimes \vrt{g^\sharp}{g} : \vrt{A^- \times C^-}{A^+ \times C^+} \leftrightarrows \vrt{B^- \times D^-}{B^+ \times D^+}\) is defined as the lens
\(\vrt{h^\sharp}{h}\), where</p>

\[h(a^+, c^+) \defeq (f(a^+), g(c^+))\]

  <p>and</p>

\[h^\sharp(a^+, c^+, b^-, d^-) \defeq (f^\sharp(a^+, b^-), g^\sharp(c^+, d^-))\]
</blockquote>

<p>Given dynamical systems</p>

\[S : \vrt{\mathit{State}_S}{\mathit{State}_S} \leftrightarrows \vrt{\mathit{In}_S}{\mathit{Out}_S}\]

<p>and</p>

\[T : \vrt{\mathit{State}_T}{\mathit{State}_T} \leftrightarrows \vrt{\mathit{In}_T}{\mathit{Out}_T}\]

<p>their parallel product</p>

\[S \otimes T : \vrt{\mathit{State}_S \times \mathit{State}_T}{\mathit{State}_S \times \mathit{State}_T} \leftrightarrows \vrt{\mathit{In}_S \times \mathit{In}_T}{\mathit{Out}_S \times \mathit{Out}_T}\]

<p>can be depicted by juxtaposing the two dynamical systems.</p>

<figure>
<img src="/assets/images/gameloop/parallel-product.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 2</figcaption>
</figure>

<h2 id="example">Example</h2>

<p>Here is an example of a dynamical system from <a href="https://www.davidjaz.com/Papers/DynamicalBook.pdf">Categorical Dynamical Systems</a>. Define the set</p>

\[\mathit{Hour} \defeq \{ 1,2,3,4,5,6,7,8,9,10,11,12 \}\]

<p>We define a dynamical system</p>

\[\mathit{Clock} : \vrt{\mathit{Hour}}{\mathit{Hour}} \leftrightarrows \vrt{1}{\mathit{Hour}} \defeq \vrt{f^\sharp}{f}\]

<p>where \(f\) is the identity function</p>

\[f(x) \defeq x\]

<p>and</p>

\[f^\sharp(h, \ast) \defeq \begin{cases}
1 &amp; \text{  if } h = 12 \\
h + 1 &amp; \text{  otherwise}
\end{cases}\]

<p>This system represents a wall clock, which takes no external input and advances one hour forward at each step.</p>

<figure>
<img src="/assets/images/gameloop/clock.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 3</figcaption>
</figure>

<p>Note that we don’t need to draw an incoming edge; because the input is \(1 = \{ \ast \}\), it transmits only one possible choice of value \(\ast\). So instead of receiving input from an external source, \(\mathit{Clock}\) can fabricate the value \(\ast\) at every step, knowing it is the correct choice.</p>

<p>The above clock does not distinguish between \(\am\) and \(\pm\) To fix this,
we define a dynamical system called \(Meridiem\) that shifts between \(\am\) and \(\pm\) We first define the set
\(\am/\pm \defeq \{ \am, \pm \}\)
Then we define</p>

\[\mathit{Meridiem} : \vrt{\am/\pm}{\am/\pm} \leftrightarrows \vrt{\mathit{Hour}}{\am/\pm} \defeq \vrt{f^\sharp}{f}\]

<p>where</p>

\[f(m) \defeq m\]

<p>and</p>

\[f^\sharp(\am,h) \defeq \begin{cases}
\pm &amp; \text{if } h = 11 \\
\am &amp; \text{otherwise}
\end{cases}\]

\[f^\sharp(\pm,h) \defeq \begin{cases}
\am &amp; \text{if } h = 11 \\
\pm &amp; \text{otherwise}
\end{cases}\]

<p>Now we need “wire together” the \(\mathit{Clock}\) and \(\mathit{Meridiem}\) systems. As a first step, we take their paralell product.</p>

\[\mathit{Clock} \otimes \mathit{Meridiem} :
\vrt{\mathit{Hour} \times \am/\pm}{\mathit{Hour} \times \am/\pm} \leftrightarrows \vrt{1 \times \mathit{Hour}}{\mathit{Hour} \times \am/\pm}\]

<figure>
<img src="/assets/images/gameloop/clock-meridiem.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 4</figcaption>
</figure>

<p>To feed the output of \(\mathit{Clock}\) into \(\mathit{Meridiem}\), we use composition, which
can be depicted as nesting.</p>

<figure>
<img src="/assets/images/gameloop/compose-clock.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 5</figcaption>
</figure>

<p>The inner dotted box is the parallel product \(\mathit{Clock} \otimes \mathit{Meridiem}\). The outer dotted box is the fully wired system. The section between the two boxes depicts a new lens</p>

\[\vrt{w^\sharp}{w} : \vrt{1 \times \mathit{Hour}}{\mathit{Hour} \times \am/\pm} \leftrightarrows \vrt{1}{\mathit{Hour} \times \am/\pm}\]

<p>defined such that</p>

\[w(h,m) \defeq (h,m)\]

<p>and</p>

\[w^\sharp(h, m, \ast) \defeq (\ast, h)\]

<p>The fully wired system, which we shall call \(\mathit{Clock}'\) is then defined as</p>

\[\mathit{Clock}' : \vrt{\mathit{Hour} \times \am/\pm}{\mathit{Hour} \times \am/\pm} \leftrightarrows \vrt{1}{\mathit{Hour} \times \am/\pm} \defeq \vrt{w^\sharp}{w} \circ (\mathit{Clock} \otimes \mathit{Meridiem})\]

<h2 id="combinational-systems">Combinational Systems</h2>

<p>Suppose that we want to translate the output of the \(\mathit{Clock}'\) system above to
24-hour time, also known as “military time”, instead of \(\am/\pm\) Let</p>

\[\mathit{Hour24} \defeq \{ 0, 1, 2, \ldots, 23 \}\]

<p>We need to “post-compose” a function \(f : \mathit{Hour} \times \am/\pm \to \mathit{Hour24}\) after
the \(\mathit{Clock}'\) system, where \(f\) is defined as follows:</p>

\[f(h, \am) \defeq \begin{cases}
0 &amp; \text{if } h = 12 \\
h &amp; \text{otherwise}
\end{cases}\]

\[f(h, \pm) \defeq \begin{cases}
12 &amp; \text{if } h = 12 \\
12 + h &amp; \text{otherwise}
\end{cases}\]

<p>Such a post-composition is depicted below</p>

<figure>
<img src="/assets/images/gameloop/24-conversion.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 6</figcaption>
</figure>

<p>Note that \(f\) is just a function, not a dynamical system with state.</p>

<p>In digital logic, a circuit that stores state is known as sequential, whereas a circuit that
merely computes a function is called combinational. The function \(f\) above, having no internal state, is combinational. We can post-compose a dynamical system by a combinational system using lens combination.</p>

<p>Without loss of generality, let \(\mathit{Out}_0 \defeq \mathit{Hour} \times \am/\pm\), let
\(\mathit{Out}_1 \defeq \mathit{Hour24}\), and let \(\mathit{In} \defeq 1\).
Then this lens should translate the system’s output using a function \(f : \mathit{Out}_0 \to \mathit{Out}_1\)  but leave the input \(\mathit{In}\) unchanged. Hence we define it as</p>

\[\vrt{\pi_1}{f} : \vrt{\mathit{In}}{\mathit{Out_0}} \leftrightarrows \vrt{\mathit{In}}{\mathit{Out}_1}\]

<p>where \(\pi_1 : \mathit{Out_0} \times \mathit{In} \to \mathit{In}\) is the projection of the second component \((o,i) \mapsto i\).</p>

<p>We then obtain our military time clock as</p>

\[\mathit{MilitaryClock} \defeq \vrt{\pi_1}{f} \circ \mathit{Clock'}\]

<h2 id="demultiplexors">Demultiplexors</h2>

<p>Imagine a turn-based board game with multiple players. At each turn, we want to provide exactly one player with the state of the board so that they can make an informed move. The challenge is to send a payload value along a different wire depending on some selector value, and to send “nothing” along all other wires. More precisely, we need a combinational circuit, called a <em>demultiplexor</em>, that takes two inputs</p>

<ul>
  <li>The <em>payload</em>, whose type \(\mathit{Payload}\) may vary</li>
  <li>The <em>selector</em> of type <strong>n + 1</strong>, deciding which, if any, of \(n\) output destinations to transmit the payload to</li>
</ul>

<p>The demultiplexor circuit has \(n\) different output wires. Their type is not quite \(\mathit{Payload}\); each wire may contain a value of type \(\mathit{Payload}\) or, if it has not been selected, it may contain “no information” of type \(1\).</p>

<p>To express the set of values that each belong to exactly one of the disjoint sets \(\mathit{Payload}\) or \(1\) we need to use a set theoretic operation called the <em>sum</em>, which is not as well known as its evil twin the Cartesian product.</p>

<blockquote>
  <p><strong>Definition</strong> Given sets \(X\) and \(Y\), their sum \(X + Y\) is defined as</p>

\[X + Y \defeq \{ (0,x) \mid x \in X \} \cup \{ (1,y) \mid y \in Y \}\]
</blockquote>

<p>By tagging values with either \(0\) or \(1\), we ensure that the elements of the two operands are treated as mutually exclusive. It may be instructive to compare the set \(1 = 1 \cup 1\) with the set \(1 + 1\).</p>

<p>While we’re at it, let’s define another set-theoretic operation.</p>

<blockquote>
  <p><strong>Definition</strong> Given sets \(X\) and \(Y\), \(X^Y\) is defined as the set of functions from \(Y\)
to \(X\). In other words, \(X^Y\) is a synonym for \(Y \to X\).</p>
</blockquote>

<p>Now we are ready to formally define the notion of demultiplexor circuits.</p>

<blockquote>
  <p><strong>Definition</strong> The <strong>demultiplexor</strong> \(\mathit{demux}(\mathit{In}, X, n)\) is the combinational lens</p>

\[\vrt{\pi_1}{f} : \vrt{\mathit{In}}{X \times (\mathbf{n + 1})} \leftrightarrows \vrt{\mathit{In}}{(1 + X)^\mathbf{n}}\]

  <p>where \(f : X \times (\mathbf{n + 1}) \to (1 + X)^\mathbf{n}\) is defined such that</p>

\[f(x, m)(k) \defeq \begin{cases}
(1,x) &amp; \text{ if } m = k \\
(0,\ast) &amp; \text{ if } m \neq k
\end{cases}\]

  <p>and \(\pi_1 : (X \times (\mathbf{n + 1})) \times \mathit{In} \to \mathit{In}\) is the second projection function</p>

\[\pi_1((x, m), i) \defeq i\]
</blockquote>

<p>Thus, the demultiplexor \(\mathit{demux}(\mathit{In}, X,n)\) allows us to either</p>

<ul>
  <li><em>Select</em> some \(m \in \mathbf{n}\) such that \((1,x)\) is transmitted along the \(m^{\mathit{th}}\) output wire and \((0,\ast)\) is transmitted along all other output wires.</li>
  <li>Or, if \(m = n\), then transmit \((0,\ast)\) along all wires.</li>
</ul>

<p>\(\mathit{demux}(\mathit{In}, X,n)\) is depicted below, where we’ve elided all but the first and last of the \(n\) output wires.</p>

<figure>
<img src="/assets/images/gameloop/demux.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Diagram 7</figcaption>
</figure>

<p>Note that \(\mathit{demux}(\mathit{In}, X, n)\) can only be post-composed with a dynamical system whose input set is \(\mathit{In}\). When a demultiplexor is post-composed with a system \(S : \vrt{\mathit{State}_S}{\mathit{State}_S} \leftrightarrows \vrt{\mathit{In}_S}{\mathit{Out}_S}\), we elide the \(\mathit{In}\) argument from \(\mathit{demux}\), instead inferring from context that \(\mathit{In} = \mathit{In}_S\):</p>

<figure>
<img src="/assets/images/gameloop/demux-postcompose.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 8</figcaption>
</figure>

<h2 id="multiplexors">Multiplexors</h2>

<p>Assume \(n\) inputs of type \((1 + X)\), and further assume that we expect at most one input to have the form \((1, x)\) while the others have the form \((0,\ast)\). We want a combinational lens that produces a single output of type \(1 + X\), and which forwards \((1,x)\) if a single input has the form \((1,x)\) and forwards \((0,x)\) otherwise.</p>

<blockquote>
  <p><strong>Definition</strong> The <strong>multiplexor</strong> \(\mathit{mux}(\mathit{In}, X, n)\) is the combinational lens</p>

\[\vrt{\pi_1}{f} : \vrt{\mathit{In}}{(1 + X)^\mathbf{n}} \leftrightarrows \vrt{\mathit{In}}{1 + X}\]

  <p>where \(f : (1 + X)^\mathbf{n} \to (1 + X)\) is defined as</p>

\[f(\phi) \defeq \begin{cases}
\phi(m) &amp; \text{if there exists a unique } m \in \mathbf{n} \text{ such that } \phi(m) = (1, x) \text{ for some } x \\
(0,\ast) &amp; \text{otherwise}
\end{cases}\]

  <p>and \(\pi_1 : (1 + X)^\mathbf{n} \times \mathit{In} \to \mathit{In}\) is the second projection function</p>

\[\pi_1(\phi, i) \defeq i\]
</blockquote>

<figure>
<img src="/assets/images/gameloop/mux.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 9</figcaption>
</figure>

<p>Similar to \(\mathit{demux}\), we typically infer the \(\mathit{In}\) argument.</p>

<figure>
<img src="/assets/images/gameloop/mux-postcompose.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 10</figcaption>
</figure>

<h1 id="tic-tac-toe">Tic-tac-toe</h1>

<p>Now we use the dynamical system techniques described above to model the game of tic-tac-toe.
We do not model any notion of a winning condition, but instead focus on the evolution of the game over time, where two agents (players) influence the environment (the board) by submitting moves in a turn-based fashion.</p>

<h2 id="overview-1">Overview</h2>

<p>To model the board, we first need a notion of cell locations. Let each bold natural number
\(\mathbf{n}\) denote the set of natural numbers less than it, i.e.
\(\mathbf{n} \defeq \{ 0, 1, \ldots, n-1 \}\). A location on a tic-tac-toe board consists of an
x-coordinate and a y-coordinate, so we define the set \(\mathit{Loc}\) of locations as</p>

\[\mathit{Loc} \defeq \mathbf{3} \times \mathbf{3}\]

<p>We name the two players Player 0 and Player 1. Elements of the set \(\mathit{Players}\) identify players</p>

\[\mathit{Players} \defeq \{ 0, 1 \}\]

<p>In a typical game of tic-tac-toe, the players use the symbols \(X\) and \(O\) to mark their cells. In our version of tic-tac-toe each player uses its own symbol, either \(0\) or \(1\) to mark cells. An unmarked cell holds the symbol \(\_\). We let \(\mathit{Sym}\) denote the set of possible symbols at a cell:</p>

\[\mathit{Sym} \defeq \{ 0, 1, \_ \}\]

<p>The state of the board is then the set of functions from locations to symbols. We thus define the set of possible board states \(\mathit{Board}\) as</p>

\[\mathit{Board} \defeq \mathit{Sym}^\mathit{Loc}\]

<p>The dynamical system underlying our tic-tac-toe game stepper is then depicted as follows:</p>

<figure>
<img src="/assets/images/gameloop/tictactoe-full.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 11</figcaption>
</figure>

<p>It contains three yet undefined stateful subsystems: \(\mathit{Player0}\), \(\mathit{Player1}\), and \(\mathit{Environment}\). Intuitively, the game stepper advances in a periodic pattern consisting of steps of four types, in order:</p>

<ul>
  <li>\(\mathit{Environment}\) receives a move from \(\mathit{Player0}\) and executes its move</li>
  <li>\(\mathit{Environment}\) submits the resulting board to \(\mathit{Player1}\)</li>
  <li>\(\mathit{Environment}\) receives a move from \(\mathit{Player1}\) and executes its move</li>
  <li>\(\mathit{Environment}\) submits the resulting board to \(\mathit{Player0}\)</li>
</ul>

<p>In sets of the form \(1 + X\), the \(1\) component on the left is typically used to mean “inactive”. For example, on turns in which \(\mathit{Player0}\) submits its move, and on turns in which the environment submits the board to a player, \(\mathit{Player1}\) outputs \((0,\ast)\). Likewise, when \(\mathit{Environment}\) submits a board to \(\mathit{Player0}\), the demultiplexor outputs \((0, \ast)\) along the bottom channel leading to \(\mathit{Player1}\).</p>

<p>Note that players can submit any location to the environment as a move. However, if the cell at the submitted location is already occupied with either \(0\) or \(1\), then the \(\mathit{Environment}\) will choose not to perform the action and advance control to the next player without changing the board.</p>

<h2 id="environment">Environment</h2>

<p>We now define the \(\mathit{Environment}\) dynamical system. Our first task is deciding its set \(\mathit{State}_{\mathit{Environment}}\) of states. First, each state should convey the current execution step type</p>

\[\mathit{StepType} \defeq \{ \mathit{ReceiveFrom}(0), \mathit{SubmitTo}(0), \mathit{ReceiveFrom}(1), \mathit{SubmitTo}(1), \mathit{IllegalState} \}\]

<p>The \(\mathit{IllegalState}\) element above should be used when \(\mathit{Environment}\) receives an invalid input combination (i.e. one which we have prevented it from receiving by design). For those familiar with digital logic, this is somewhat analogous to a “don’t care” value.</p>

<p>Additionally, the state should convey the current board. We’ve already defined the set \(\mathit{Board}\) of board states above. Hence, our full state set is defined as</p>

\[\mathit{State}_{\mathit{Environment}} \defeq \mathit{StepType} \times \mathit{Board}\]

<p>As figure 11 shows, the environment’s output set is</p>

\[\mathit{Out}_{\mathit{Environment}} \defeq (1 + \mathit{Board}) \times \mathbf{3}\]

<p>The environment’s \(\mathit{output}_\mathit{Environment} : \mathit{State}_{\mathit{Environment}} \to \mathit{Out}_{\mathit{Environment}}\) function is then defined as</p>

\[\mathit{output}_\mathit{Environment} : \mathit{StepType} \times \mathit{Board} \to (1 + \mathit{Board}) \times \mathbf{3}\]

\[\mathit{output}_\mathit{Environment}(t, b) \defeq \begin{cases}
((1, b), n) &amp; \text{ if } t = SubmitTo(n) \\
((0, \ast), 2) &amp; \text{ if } t = ReceiveFrom(n)
\end{cases}\]

<p>Consulting figure 11, we see that</p>

\[\mathit{In}_{\mathit{Environment}} \defeq 1 + \mathit{Loc}\]

<p>For \(b \in \mathit{Board}\), we define \(b[\ell \mapsto n] \in \mathit{Board}\) as follows.</p>

\[b[\ell \mapsto n](k) \defeq \begin{cases}
b(k) &amp; \text{if } k \neq \ell \\
n &amp; \text{if } k = \ell
\end{cases}\]

<p>We define \(\mathit{nextState}_{\mathit{Environment}} : \mathit{In}_{\mathit{Environment}} \times \mathit{State}_{\mathit{Environment}} \to \mathit{State}_{\mathit{Environment}}\) as
\(~\\\)
\(\mathit{nextState}_{\mathit{Environment}} : (1 + \mathit{Loc}) \times \mathit{StepType} \times \mathit{Board} \to \mathit{StepType} \times \mathit{Board}\)
\(\mathit{nextState}_{\mathit{Environment}}((1,\ell), ReceiveFrom(n), b) \defeq \begin{cases}
(SubmitTo((n+1)~\%~2), b[\ell \mapsto n]) &amp; \text{if } b(\ell) = \_ \\
(SubmitTo((n+1)~\%~2), b) &amp; \text{otherwise}
\end{cases}\)
\(\mathit{nextState}_{\mathit{Environment}}((0,\ast), SubmitTo(n), b) \defeq (ReceiveFrom(n), b)\)</p>

<p>and for any other \((z,s,b) \in (1 + Loc) \times \mathit{StepType} \times Board\) we define
\(\mathit{nextState}_{\mathit{Environment}}(z,s,b) \defeq (\mathit{IllegalState}, b)\)</p>

<p>Finally, we define</p>

\[\mathit{Environment} : \vrt{\mathit{State}_{\mathit{Environment}}}{\mathit{State}_{\mathit{Environment}}} \leftrightarrows \vrt{\mathit{In}_{\mathit{Environment}}}{\mathit{Out}_{\mathit{Environment}}} \defeq \vrt{\mathit{nextState_{\mathit{Environment}}}}{\mathit{output}_{\mathit{Environment}}}\]

<h2 id="players">Players</h2>

<p>We define \(\mathit{Player0}\), eliding \(\mathit{Player1}\) as it is essentialy the same.</p>

<p>The state of the player systems can be used for two purposes. First, the state must record a \(Board\) whenever it is received from the environment. That way the player can use the board to compute a move on the next turn. Second, and optionally, a player’s state can serve as its brain by storing information about plan or strategy that the player is currently executing, or by storing an inferred mental model of the opposing player. We will keep things simple and decide moves in a stateless fashion, using only the current state of the board. Hence, we define</p>

\[\mathit{State}_{\mathit{Player0}} \defeq 1 + \mathit{Board}\]

<p>If the player’s state is \((1, b)\) then it has just received board \(b\) from the environment and is expected to submit a move on the next turn. Otherwise, the player’s state is \((0,\ast)\).</p>

<p>We can see from Diagram 11 that</p>

\[\mathit{In}_{\mathit{Player0}} \defeq 1 + \mathit{Board}\]

<p>and</p>

\[\mathit{Out}_{\mathit{Player0}} \defeq 1 + \mathit{Loc}\]

<p>Let \(\phi : \mathit{Board} \to \mathit{Loc}\) be player 0’s “strategy” for deciding a move given the current board; instead of defining it, we leave it as a parameter to the system.</p>

<p>We then define</p>

\[\mathit{output}_{\mathit{Player0}}(x) \defeq \begin{cases}
(0, \ast) &amp; \text{if } x = (0, \ast) \\
(1, \phi(b)) &amp; \text{if } x = (1, b)
\end{cases}\]

<p>and</p>

\[\mathit{nextState}_{\mathit{Player0}}((1, b), x) \defeq (1, b)\]

\[\mathit{nextState}_{\mathit{Player0}}((0, \ast), x) \defeq (0, \ast)\]

<p>The \(\mathit{Player0}\) dynamical system is then defined as</p>

\[\mathit{Player0} : \vrt{\mathit{State}_{\mathit{Player0}}}{\mathit{State}_{\mathit{Player0}}} \leftrightarrows \vrt{\mathit{In}_{\mathit{Player0}}}{\mathit{Out}_{\mathit{Player0}}} \defeq \vrt{\mathit{nextState}_{\mathit{Player0}}}{\mathit{output}_{\mathit{Player0}}}\]

<h2 id="putting-things-together">Putting things together</h2>

<p>Now that all of the components of our system have been defined, we will wire them together using the lens composition technique, expressing the system as a whole as a mathematical expression.</p>

<p>As a first step, we note that our system can be obtained by wiring together the two dynamical systems named \(A\) and \(B\) displayed below.</p>

<figure>
<img src="/assets/images/gameloop/tictactoe-full-ab.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 12</figcaption>
</figure>

<p>Where</p>

\[A \defeq \mathit{mux}(\mathit{Move}, 2) \circ (\mathit{Player0} \otimes \mathit{Player1})\]

<p>and</p>

\[B \defeq \mathit{demux}(\mathit{Board}, 2) \circ \mathit{Environment}\]

<p>Next, we take their parallel product \(A \otimes B\), which is depicted below.</p>

<figure>
<img src="/assets/images/gameloop/AB-juxtapose.drawio.png" style="margin-top: 30px; margin-bottom: 30px" />
<figcaption>Figure 13</figcaption>
</figure>

<p>Finally, to close off our system, we must wire together the two components using lens composition, similar to how we wired together the \(\mathit{Clock}\) and \(\mathit{Meridiem}\) systems above.</p>

<p>We use the wiring lens</p>

\[\vrt{w^\sharp}{w} : \vrt{(1 + \mathit{Board}) \times (1 + \mathit{Board}) \times (1 + \mathit{Loc})}{(1 + \mathit{Loc}) \times (1 + \mathit{Board}) \times (1 + \mathit{Board})} \leftrightarrows \vrt{1}{1}\]

<p>where</p>

\[w(\ell, b_0, b_1) \defeq \ast\]

<p>and</p>

\[w^\sharp(\ell, b_0, b_1, \ast) \defeq (b_0, b_1, \ell)\]

<p>Our complete system is then equal to:</p>

\[\vrt{w^\sharp}{w} \circ (A \otimes B)\]

<h1 id="conclusion">Conclusion</h1>

<h2 id="evaluating-the-dynamical-systems-formalism">Evaluating the Dynamical Systems Formalism</h2>

<p>It’s worth taking a step back to ask whether the lens-based dynamical systems formalism is an appropriate tool for modelling turn-based computer games. The ability of lenses to represent cyclic data flow, from the players to the environment and back to the players, is essential. Additionally, lens based dynamical systems make it easy for us to encapsulate data, restricting a players to mutate only their own mental state, and restricting the environment to only mutate the physical world.</p>

<p>One drawback is that, due to the inherently concurrent nature of lens-based dynamical systems, we’ve needed to insert machinery for synchronization, which has little to do with dynamics of our turn-based games. For example, giving most wires the type \(1 + X\) is a distraction.</p>

<h2 id="looking-ahead">Looking ahead</h2>

<p>Now that we’ve developed a mathematical model of a game stepper for tic-tac-toe, let’s recall the significant features listed at the end of my <a href="/posts/2025/07/11/towards-mathematical-model.html">previous post</a> and consider how well the model implements these features.</p>

<ul>
  <li>✅ A robot performs physical actions by submitting requests to an environment. The environment decides whether to honor these requests.</li>
  <li>✅ A robot has internal state, but it’s a purely “mental” state that is used to make decisions. Physical properties of the robot are stored in the environment’s internal state.</li>
  <li>❌ A robot may send a message to another robot, which represents information sent along some physical communication medium.</li>
</ul>

<p>Our model implements the first two features. The game board can be seen as the environment, which encapsulates all physical information, namely the contents of every cell on the game board. A player can be seen as a robot; by virtue of being a dynamical systems, it encapsulates its own private data, i.e. mental state.</p>

<p>The last feature, message passing among robots, is not present in the model I described. Speculating, in a game’s source code, message passing might look similar to the following pseudo-code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// When the player switches off the fuse box, this channel notifies all subscribers.
channel fuse_box_off : 1;

robot roy {
  receives on fuse_box_off;

  state working {
    handler fuse_box_off (_ : 1) = {
      set_state(fix_fusebox);
    }
  }

  state fix_fusebox {
    ...
  }
}

robot fuse_box {
  sends on fuse_box_off;

  state on {
    handler on_player_touch (_ : 1) = {
      send fuse_box_off(*);
      set_state(off);
    }
  }

  state off {
    ...
  }
}
</code></pre></div></div>

<p>Our program starts with a list of channel declarations. A channel declaration includes both a name and the type of messages sent along the channel. In this example, our channel is named <code class="language-plaintext highlighter-rouge">fuse_box_off</code> and has type \(1\), where \(1\) is the type of containing a single information-free value \(\ast\).</p>

<p>Each robot is implemented as a state machine. A robot definition begins with a list of declarations stating which channels the robot may send and receive upon. Next, the robot defines a list of states. These states can declare <em>handlers</em> to provide code that executes when a message is received, and the handlers in turn can issue <code class="language-plaintext highlighter-rouge">send</code> commands, which broadcast values to all of the subscribers of a channel.</p>

<p>If a robot sends a message along a channel, when is the message received by the channel’s subscribers? Our answer is that it is received on the next frame. The reason for this is that all robots acting on a frame are assumed to be acting at roughly the same time: times so close together that their difference is considered too fine-grained for our game engine to track.</p>

<p>A game engine may very reasonably execute multiple robot scripts in sequence on a single frame, but having the second robot receive messages sent by the first robot on the same frame is problematic. Not only does it violate our intuition that all robots are executing “at the same time” on a single frame, but it creates a hidden rule where a message sent from one robot to another may or may not arrive until the next frame depending on which robot was processed first.</p>

<p>If two robots transmit messages along the same channel on the same frame, which message do the channel’s subscribers process first? Since both messages are considered to be sent “at the same time,” our game system is too coarse-grained to answer this question. Our model should therefore non-deterministically permit any ordering. However, our current dynamical system formalism doesn’t support non-determinism.</p>

<p>The next blog post will correct this by extending the formalism with non-deterministic state transitions. It will also present a basic model of MegaZeux where all robots operate concurrently at every frame. We won’t have time to model message channels in that post, but by introducing non-determinism into the MegaZeux model, we will establish the foundation needed to add message passing in a subsequent post.</p>

<hr />

<p><strong>Next:</strong> <a href="/2025/11/04/modelling-megazeux.html">Modelling MegaZeux</a></p>

  </div><a class="u-url" href="/2025/10/18/modelling-tic-tac-toe.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          
        </ul>
      </div>
      <div class="footer-col">
        <p></p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
